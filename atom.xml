<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sanmuny.github.io</id>
    <title>三木的技术博客</title>
    <updated>2021-08-12T08:26:49.015Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sanmuny.github.io"/>
    <link rel="self" href="https://sanmuny.github.io/atom.xml"/>
    <subtitle>Honesty and diligence should be your eternal mates.</subtitle>
    <logo>https://sanmuny.github.io/images/avatar.png</logo>
    <icon>https://sanmuny.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 三木的技术博客</rights>
    <entry>
        <title type="html"><![CDATA[云原生概要]]></title>
        <id>https://sanmuny.github.io/post/J-lgDABdS/</id>
        <link href="https://sanmuny.github.io/post/J-lgDABdS/">
        </link>
        <updated>2021-08-12T08:15:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是云原生">什么是云原生</h1>
<h2 id="设计目的">设计目的</h2>
<p>云原生软件的设计目的是预测故障，并且即使当它所依赖的基础设施出现故障，或者发生其他变化时，它也依然能够保持稳定运行。</p>
<p>将变化或者失败视为正常规律，让面向失败的设计成为它们构建、交付和管理软件过程中的一个组成部分。</p>
<h2 id="云计算时代应用需求">云计算时代应用需求</h2>
<ol>
<li>
<p>零停机时间<br>
软件开发人员或者架构师对设计和开发一个松耦合、组件化的系统同样负有责任，应该通过部署冗余组件来应对不可避免的故障，并设置隔离机制来防止故障在整个系统中引起连锁反应。而且，还必须把软件设计成能够在不停机的情况下完成计划事件（例如，升级）。</p>
</li>
<li>
<p>缩短反馈周期<br>
频道的软件发布可以缩短反馈周期，降低风险</p>
</li>
<li>
<p>多设备支持<br>
用户越来越希望他们的应用体验随时可以从一个设备无缝切换到另一个设备上。</p>
</li>
<li>
<p>互联设备（物联网）<br>
数据量和基础架构之间的差异，需要新的软件设计和实践来解决。</p>
</li>
<li>
<p>数据驱动<br>
数据量正在不断增加，数据源分布得更加广泛，而软件的交付周期正在缩短<br>
这些应用程序需要的不是单一的共享数据库，而是一个由更小的、本地化数据库组成的网络，以及能够在多个数据库管理系统之间管理数据关系的软件。</p>
</li>
</ol>
<h2 id="定义">定义</h2>
<p>云原生软件是高度<strong>分布式</strong>的，必须在一个不断变化的环境中运行，而且自身也在不断地发生<strong>变化</strong></p>
<h2 id="不适合使用云原生架构的情形">不适合使用云原生架构的情形</h2>
<ol>
<li>不需要云计算的软件，例如嵌入到家电中的软件。</li>
<li>云原生提供的是最终一致性，但如果需要数据强一致性的话，云原生架构就不适用了。</li>
<li>用云原生架构重写软件时并没有提供新的价值</li>
</ol>
<h2 id="云原生的价值">云原生的价值</h2>
<p>云原生的绝妙之处在于它最终是由许多不同组件组成的，即使其中一些组件的模式不是最新的，云原生组件也可以与他们进行交互。即使你的软件使用了旧的模式，应用云原生模式依然可以带来立竿见影的效果。</p>
<h1 id="云原生与持续交付">云原生与持续交付</h1>
<h2 id="生产环境运维面临的困难">生产环境运维面临的困难</h2>
<p><strong>1. 碎片化的变化</strong></p>
<ul>
<li>环境发生变化</li>
<li>部署的构件发生变化</li>
</ul>
<p><strong>2. 部署是有风险的</strong><br>
部署通常充满危险。在升级期间需要停机或者部署时引起意外停机都是很正常的，而停机的代价是昂贵的。</p>
<p><strong>3. 传统运维认为变化是例外</strong><br>
开发人员通常会在初次部署之后退出，然后由运维人员接管。运维团队手里只有一本运维手册。虽然运维手册详细描述了可能的失败场景及其解决方案，但是更加深入思考一下不难了解，手册设定了一个假设，就是失败场景是已知的。但是，绝大多数情况不是这样的！</p>
<p><strong>4. 生产环境的不稳定性</strong></p>
<h2 id="云原生架构运维的解决办法">云原生架构运维的解决办法</h2>
<p><strong>目标</strong></p>
<ul>
<li>简单且可以频繁地在生产环境中进行发布。</li>
<li>运维具有稳定性和可预测性。</li>
</ul>
<h3 id="持续交付continuous-deliverycd">持续交付（Continuous delivery，CD）</h3>
<p><strong>1. 什么是持续交付</strong><br>
持续交付的每个开发/测试流程都不会进行部署，但每个流程都会生成可以交付的软件。之后，是否部署就看商业决策了，而传统的软件交付则是在创建可以发布到生产环境中的构件之前，会提前进行大量的开发工作和一个长时间的测试流程</p>
<p><strong>2. 持续交付的优势</strong></p>
<ul>
<li>何时进行下一次软件发布依赖于商业决策，而不是由一个复杂、不可预测的软件开发过程决定的</li>
<li>有机会收集反馈，并用来改进产品的后续版本</li>
</ul>
<h3 id="可重复部署">可重复部署</h3>
<p>部署可重复有助于系统部署和保证系统的稳定性，并且通过在每次开发/测试的迭代过程中控制变化风险，可以缩短整个新功能的交付时间。</p>
<p>达到部署可重复手段包括：</p>
<p><strong>1. 控制环境</strong></p>
<p>你必须从标准化的机器镜像开始。例如，从一个基础Ubuntu镜像开始，并且软件需要Java开发工具包（JDK），那么可以通过脚本将JDK安装到基础镜像中。此模式也经常被称为基础设施即代码（Infrastructure as Code）。当需要一个环境的新实例时，可以从基础镜像开始并执行脚本，这样就可以保证每次都拥有相同的环境。</p>
<p><strong>2. 控制可部署构建</strong><br>
一旦你为软件开发生命周期的不同阶段构建了不同的构件，可重复性就可能受到影响。为了实现高效、安全和可重复的生产环境运维，不要把环境相关的配置包含到代码中。</p>
<p><strong>3. 控制流程</strong><br>
将各个部分组合起来并确保一致性的唯一方法就是自动化。</p>
<h3 id="安全部署">安全部署</h3>
<ol>
<li>并行部署和版本化的服务<br>
安全部署的核心是并行部署。与用新版本完全替换一个正在运行的软件版本不同，你可以在部署新版本的同时让已有的版本继续运行。一开始，只有一小部分流量被路由到新的版本，然后你可以观察会发生什么。你可以根据各种条件来控制哪些流量被路由到新的版本，例如请求来自何处（例如，来自某个地理位置或者引用页）或者用户是谁。</li>
<li>进行必要的远程监控</li>
<li>灵活的路由</li>
</ol>
<ul>
<li>软件构件必须实现版本控制，并且版本必须对路由可见，以便恰当地切分流量</li>
<li>用于分析新版本工作情况的数据可以有多种形式</li>
<li>路由是并行部署的一个关键因素，而路由算法属于软件的一部分</li>
<li>创建更小的部署单元</li>
</ul>
<h3 id="变化是一定的">变化是一定的</h3>
<p>在不断变化的情况下保持系统功能的完整性，是我们设计软件的最终目标，而变化对系统稳定性和可靠性的影响也是显而易见的。一个能够自我修复的系统，其正常运行的时间比每次出故障都需要人工干预的系统要长得多。将部署作为一种新的期望状态，可以极大地简化部署过程并降低风险。坚持“变化是一定的”的思维模式，可以从根本上改变在生产环境中管理软件的方式。</p>
<h1 id="云原生平台">云原生平台</h1>
<h3 id="云原生平台的发展">云原生平台的发展</h3>
<ul>
<li>AWS：软件架构、开发和运维并没有太多的改变。优势是成本降低，但故障率偏高，API中引入了AZ的概念，继而影响软件架构</li>
<li>GAE以及Azure：限制了用户代码直接对计算、存储、网络资源的访问，提供了安全性及弹性的保证</li>
<li>云原生平台：IaaS平台是一个提供访问基础设施（例如，主机、存储和网络）的接口，而云原生平台则是一个让应用程序成为开发人员或运维人员最主要的交互对象的接口</li>
</ul>
<h3 id="云原生平台的核心原则">云原生平台的核心原则</h3>
<ul>
<li>使用比虚拟机更加轻量级的容器技术</li>
<li>支持不断变化<br>
系统管理是通过不断监控系统的实际状态（不断变化的），将其与期望状态进行比较，并在必要时进行调整来实现预期的。</li>
<li>支持高度分布式<br>
应用程序自己的环境中运行多个微服务，同时支持独立开发并降低级联失败的影响。它们的确能带来这些好处，但是随之产生的是一个由分布式组件组成的系统，而非原来单个组件或者单个进程的架构，因此要面临的复杂性也是之前不存在的（或者很少存在）。<br>
支持分布式的平台需要提供如下功能：</li>
</ul>
<ol>
<li>服务发现：单独的服务运行在不同的容器和不同的主机上，为了让一个服务能够调用另一个服务，它必须首先能够找到另一个服务</li>
<li>服务配置</li>
<li>分布式跟踪机制，允许自动将跟踪器嵌入请求中，以诊断多个微服务调用之间的问题。</li>
<li>断路器，防止意外产生的内部DDoS攻击，例如，网络中断时可能产生的重试风暴。</li>
</ol>
<h1 id="事件驱动模式">事件驱动模式</h1>
<p>顺序式的编程模型会促使你以请求/响应的方式进行思考。<br>
如果请求只有在犹如树状的所有级联请求都成功的情况下才能成功，那么微服务的可用性会降低很多。</p>
<ul>
<li>“请求/响应”微服务：接收到请求时执行的代码，会直接决定向请求者提供某种响应。</li>
<li>事件驱动的微服务：代码执行的结果与触发它的事件没有直接关系。</li>
</ul>
<p>事件驱动的核心思想在于，因为事件导致代码被执行，然后可能会产生更多的事件。</p>
<p>对于请求/响应的方式，聚合发生在用户发出请求的时候。而对于事件驱动的方式，聚合发生在系统中数据发生变化的时候，并且这是异步的。</p>
<p>在请求/响应的微服务架构中，重试是补偿网络分区的一个关键模式。在事件驱动的系统中，事件存储是对网络不稳定性的一个关键补充</p>
<h3 id="命令查询责任分离cqrs模式">命令查询责任分离（CQRS）模式</h3>
<p>将写逻辑（命令）与读逻辑（查询）分离开来。这就是命令查询责任分离（CQRS）模式的核心思想。CQRS的核心就是将这两个关注点分离开来。其优点在于，</p>
<ol>
<li>写少量的数据，读取时可以通过计算得到更多的数据</li>
<li>读取可以采用请求与响应模式，但更新数据可以采用时间驱动模式</li>
</ol>
<h1 id="水平伸缩与无状态">水平伸缩与无状态</h1>
<h3 id="水平伸缩">水平伸缩</h3>
<p>灵活的伸缩性并不是采用多个实例的唯一动机，高可用、可靠性和运维效率也同样是考虑因素，例如避免单点故障、在线升级等</p>
<h3 id="无状态">无状态</h3>
<p>对于云原生应用，相同的输入应该产生相同的结果，无论有多少实例，也无论请求被路由到哪个实例。</p>
<p>云原生不能继续使用黏性会话来处理有状态的服务，因为黏性会话指定的实例可能已经消失，或者由于网络异常而无法访问</p>
<p>云原生应用程序有存在状态的地方，同样重要的是，也有不存在状态的地方。应用程序应该是无状态的，状态应该存在于数据服务中。</p>
<p><strong>无状态的优势</strong></p>
<ol>
<li>当你的应用程序处于无状态时，云原生应用程序平台可以在旧的实例丢失的时候，轻松创建新的实例</li>
<li>可以有效地管理一个应用程序的多个版本，所有这些版本都可以同时部署和运行</li>
</ol>
<h1 id="应用程序配置">应用程序配置</h1>
<ul>
<li>创建合适的抽象，将应用程序的部署参数化，从而在正确的时间、以合理的方式将不同环境中的参数值注入应用程序</li>
<li>比环境变量更好的方法是在应用程序中使用一个特定的配置层，可以在这里查看某个应用程序的所有配置选项。</li>
<li>可以将环境变量映射到配置文件中</li>
<li>也可以利用应用程序框架将配置注入到配置文件中</li>
</ul>
<h3 id="使用配置层的优点">使用配置层的优点</h3>
<ol>
<li>所有配置参数都定义在同一个地方，开发人员或者运维人员可以轻松地查看和理解应用程序的配置参数。</li>
<li>属性文件会被编译成一个单独的可部署构件，并且可以被实例化到任何环境中。</li>
</ol>
<h1 id="应用程序升级">应用程序升级</h1>
<ul>
<li>蓝绿升级：建立另一组实例，所有这些实例都拥有新的配置，然后将所有流量从第一组实例切换到第二组实例。运行中的版本称为“蓝色”版本，希望部署的新版本称为“绿色”版本。</li>
<li>滚动升级：滚动部署应用程序的实例，用一组新实例替换一组旧实例的子集，然后继续下一个子集。</li>
</ul>
<ol>
<li>
<p>蓝/绿升级比滚动升级需要更多的资源。</p>
</li>
<li>
<p>如果你构建的应用程序可以同时运行多个版本，那么你可以让一些消费者仍然使用旧的版本，而让另一些消费者使用新的版本。我们称之为并行部署。</p>
</li>
<li>
<p>除了支持滚动升级，并行部署的另一个用途是支持灰度发布。</p>
</li>
<li>
<p>密码更新策略：服务端同时支持新旧密码以保证零停机更新</p>
</li>
</ol>
<h1 id="服务发现">服务发现</h1>
<h3 id="服务">服务</h3>
<ul>
<li>单个服务代表了多个应用程序实例。</li>
<li>在云原生软件中，应用程序被部署为多个实例。为了让软件可以正常运行，你会希望每一组实例都作为一个单独的逻辑实体来运行</li>
<li>软件被定义为多个服务的组合。每个服务都是由一组服务实例来实现的</li>
</ul>
<h3 id="动态路由">动态路由</h3>
<p>服务如何与它们所代表的应用程序实例关联</p>
<ol>
<li>
<p>更新实例列表</p>
</li>
<li>
<p>负载均衡</p>
</li>
</ol>
<ul>
<li>禁止使用粘性会话</li>
<li>使用集中式的负载均衡器而不是分布式的</li>
</ul>
<p>集中式负载均衡器的优势：</p>
<ul>
<li>技术成熟</li>
<li>实现易于理解</li>
<li>配置容易</li>
<li>为避免单点故障应该部署多个实例</li>
</ul>
<p>客户端负载均衡是在客户端配置负载均衡器，这样http请求就会直接发送给服务的某个实例，减少了一次网络跳转，性能更好</p>
<h3 id="服务发现-2">服务发现</h3>
<p>服务的客户端如何发现和找到服务</p>
<ol>
<li>Kubernetes集群会提供一个名为CoreDNS的DNS服务。</li>
<li>在启动时，Kubernetes会将服务的名称和地址添加到CoreDNS服务中。</li>
<li>在Kubernetes环境中运行的所有pod（应用程序），都会配置CoreDNS服务的地址。</li>
<li>任何访问DNS的操作，例如，对包含某个名称的URL发出HTTP请求，都需要访问CoreDNS服务来解析地址。</li>
</ol>
<h1 id="交互冗余">交互冗余</h1>
<h3 id="重试">重试</h3>
<p>应用程序向远程服务发出请求，如果在合理的时间内没有接收到响应，将再次尝试。</p>
<p>重试风暴：使用重试时，系统需要15分钟才能从3分钟的网络中断中恢复。如果不使用重试，则可以立即从3分钟的网络中断中恢复。</p>
<p>重试既会造成灾难性的影响，但是又有巨大的好处，尤其是在调用只是间歇性失败的情况下。</p>
<p>友好的客户端会：</p>
<ol>
<li>限制重试的次数</li>
<li>降低重试的频率</li>
</ol>
<p>安全的方法：一个安全的方法是指可以被调用零次或者多次，而且效果相同。该方法不应该有其他任何副作用。如GET、HEAD、OPTIONS和TRACE</p>
<p>幂等的方法：一个幂等的方法是指可以被调用一次或者多次，而且效果相同。它可以有副作用，但是所有重复调用的副作用必须与第一次相同。如，PUT</p>
<p>重试安全的方法，而不是重试幂等的方法</p>
<h3 id="回退逻辑">回退逻辑</h3>
<p>面向失败设计最基本的模式之一，是实现回退的方法，即当主逻辑失败时执行的代码。</p>
<h3 id="控制循环">控制循环</h3>
<p>控制循环永远不会期望达到完成的状态。它的目的就是不断地寻找不可避免的变化，并做出适当的响应。</p>
<h1 id="断路器和api网关">断路器和API网关</h1>
<h3 id="断路器">断路器</h3>
<p>如果服务开始出现故障但是次数不多，先停止该服务的所有流量一段时间，希望给它一段时间，让它能够从故障中恢复。过一段时间后，让单个请求通过，查看其运行情况。如果请求失败，则继续维持保护措施，不允许后续的流量通过。如果请求成功，看看则视为服务恢复正常，并允许流量通过。</p>
<p>断路器状态：打开、关闭、半开</p>
<h3 id="api网关-服务网格实现">API网关 服务网格实现</h3>
<p>API网关始终位于实现的最前面，并且提供了大量的服务。这些服务可能包括以下内容。</p>
<ol>
<li>身份验证和授权</li>
<li>加密解密</li>
<li>限流</li>
<li>访问日志</li>
</ol>
<p>API网关模式的目标之一是将服务开发人员的关注问题与运维的关注问题分开。希望让后者能够统一控制正在运行的服务，并且为他们提供一个易于管理的控制平面。</p>
<h1 id="服务网格">服务网格</h1>
<h3 id="挎斗sidecar">挎斗Sidecar</h3>
<p>简单来看，挎斗是一个与主服务一起运行的进程，或者是与主服务容器运行于同一个pod中的容器。</p>
<p>Kubernetes pod中运行的所有服务都可以托管在相同的IP地址上，这意味着它们可以通过localhost互相寻址，因此网络开销将变得很小。</p>
<h1 id="打破数据单体">打破数据单体</h1>
<h3 id="微服务需要缓存">微服务需要缓存</h3>
<ol>
<li>提升性能</li>
<li>当下游服务出现故障时，由于缓存的存在，请求也有可能成功</li>
</ol>
<h3 id="数据一致性">数据一致性</h3>
<p>请求/响应模式 转变为 事件驱动的方式</p>
<p>问题在于事件通知机制失败时，缓存中的数据可能是损坏的，而且可能会无限期的保持下去。解决方法为：</p>
<p>使用异步的消息传递系统，而不是直接发送消息给需要的微服务</p>
<p>事件载荷的规则1 一个被发布到事件日志中的事件，应该完整地进行描述。<br>
事件载荷的规则2 对于事件日志来说没有标准的事件模型。生产者可以控制所传递事件的数据格式，而消费者应该适配该格式。<br>
事件载荷的规则3 所有发布到事件日志的事件都必须有一个相关的结构（schema），供所有相关方访问，并且必须对该结构进行版本控制。</p>
<p>事件消费者，规则1 尽可能让事件消费者的操作是幂等的。</p>
<p>Envoy在这些交互的边缘实现了许多模式，包括重试、断路器、限速、负载均衡、服务发现、可观察性等。</p>
<p>Istio的口号是“连接、安全、控制和观测服务”，支持自动注入挎斗并提供Envoy代理配置、证书处理和策略执行的组件。控制平面API提供了与此管理控制平面相关的接口。</p>
<h1 id="日志-监控与跟踪">日志、监控与跟踪</h1>
<h3 id="应用程序日志">应用程序日志</h3>
<p>3日志出现的位置应该完全由应用程序部署来控制，而不是由应用程序本身来决定。日志消息是出现在指定文件中还是出现在控制台中，或者出现在其他地方，都应该在部署时确定。</p>
<p>对云原生应用程序来说，该部署配置应该将日志行发送到stdout和stderr。这是因为：</p>
<ol>
<li>禁止将日志直接写入文件。本地文件系统与容器的生命周期是一致的。</li>
<li>stdout和stderr与供应商无关</li>
<li>stdout和stderr与操作系统无关</li>
<li>stdout和stderr是流式API，日志本身也是流。</li>
</ol>
<p>日志需要进行大规模提取和存储，并且接口必须支持对这些海量数据的搜索和分析。ELK技术栈（详情参见链接46）汇集了三个开源项目—Elasticsearch、Logstash和Kibana—来满足这些要求。</p>
<h3 id="应用程序监控">应用程序监控</h3>
<p>在基于拉的方法中，度量指标聚合器会作为一个收集器，从每个应用程序实例中收集请求指标数据，并将这些指标存储在时序数据库中。问题在于，<br>
有多个经过负载均衡的应用程序实例，你只能从其中一个实例获取指标，并且不知道具体是哪个实例。这。</p>
<p>基于推的模式，其中，每个应用实例负责按固定时间间隔将指标发给指标聚合器。一个挎斗代理不仅可以提供指标值，还可以代理应用程序发来的指标推送，因为即使应用程序没有安装代理（Agent），挎斗依然可以提供一定程度的可观察性。因为它代理了进出应用程序的流量，所以可以代替应用程序来生成许多指标</p>
<h3 id="应用程序跟踪">应用程序跟踪</h3>
<p>分布式跟踪解决的是如何跨多个分布式组件来跟踪程序流的问题。</p>
<p>Zipkin是当今使用的一种流行技术，核心包括以下几方面内容：</p>
<ul>
<li>使用跟踪器（tracer）在请求和响应中插入唯一标识符，以便找到相关的应用程序调用。</li>
<li>一个控制平面（control plane）使用这些跟踪器将一组调用组装成调用图（或者是特意设计的独立调用）。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Javascript中的异步编程]]></title>
        <id>https://sanmuny.github.io/post/OecN7NV6c/</id>
        <link href="https://sanmuny.github.io/post/OecN7NV6c/">
        </link>
        <updated>2020-01-15T08:15:37.000Z</updated>
        <summary type="html"><![CDATA[<p>Javascript最开始是用于浏览器中的前端编程语言。Javascript是单线程的，为了能及时响应用户操作，javascript对耗时操作（如Ajax请求、本地文件读取等)的处理是异步进行的，也即是所谓的异步编程。除了快速响应用户操作之外，另外一个让javascript采用异步方式的原因是，程序无法预知用户会进行哪些操作。比如说程序无法提前知道用户是点“取消”按钮还是“确定”按钮。所以，Javascript采用了事件注册的方式来处理这个问题。在程序编写时，可以给用户点击“取消”按钮和“确认”按钮注册不同的回调函数，这样当用户点击不同的按钮时，不同的回调函数会被执行。本文从回调函数开始，介绍了Promise、async/await几种Javascript主要的异步编程方式。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Javascript最开始是用于浏览器中的前端编程语言。Javascript是单线程的，为了能及时响应用户操作，javascript对耗时操作（如Ajax请求、本地文件读取等)的处理是异步进行的，也即是所谓的异步编程。除了快速响应用户操作之外，另外一个让javascript采用异步方式的原因是，程序无法预知用户会进行哪些操作。比如说程序无法提前知道用户是点“取消”按钮还是“确定”按钮。所以，Javascript采用了事件注册的方式来处理这个问题。在程序编写时，可以给用户点击“取消”按钮和“确认”按钮注册不同的回调函数，这样当用户点击不同的按钮时，不同的回调函数会被执行。本文从回调函数开始，介绍了Promise、async/await几种Javascript主要的异步编程方式。</p>
<!-- more -->
<h1 id="异步编程和回调函数">异步编程和回调函数</h1>
<p>无论是Ajax请求，还是事件处理，Javascript都是通过回调函数来完成的。谈及异步编程和回调函数，可以回想一下操作系统中的中断及中断处理程序。由于CPU的速度比外设快出许多，为了提高CPU的处理效率，计算机系统引入了中断的概念，外设在读写数据的时候，CPU可以忙别的事情，等到外设读写完数据后，会给CPU发一个中断信号，CPU就可以来执行已经注册好的、相应的中断处理程序。Javascript中的回调函数和中断处理程序都是类似的原理。</p>
<p>先来看一个异步的例子：</p>
<pre><code>console.log(&quot;Start...&quot;);
setTimeout(()=&gt;{
  console.log(&quot;in progress&quot;);
}, 2000);
console.log(&quot;End...&quot;);
</code></pre>
<p>如果是同步的话，输出的顺序应该是：</p>
<pre><code>Start...
in progress
End...
</code></pre>
<p>然而真实的输出结果却是这样的：</p>
<pre><code>Start...
End...
in progress
</code></pre>
<p>原因在于setTimeout中的第一个参数，箭头函数(即上文所说的回调函数)是异步执行的。setTimeout相当于注册一个回调函数，该回调函数在2000毫秒(2秒)之后运行。由于是异步的，主程序并不会等到两秒之后才跑setTimeout后面的代码，而是立即执行，所以先输出了<code>End...</code>，2秒之后，注册的回调函数运行了，输出了<code>in progress</code>。</p>
<p>举一反三，Ajax请求、事件处理都是类似的。比如：</p>
<pre><code>$.ajax({
  url: url,
  data: data,
  success: ()=&gt;{},
  dataType: dataType
});

$('#mydiv').on('click', ()=&gt;{})
</code></pre>
<p>其中的两个箭头函数就是回调函数。</p>
<p>当后面的异步操作依赖于前面异步操作的结果时，就需要在回调函数中嵌套回调函数，例如：</p>
<pre><code>console.log(&quot;Start...&quot;);
setTimeout(()=&gt;{
  console.log('A');
  setTimeout(()=&gt;{
    console.log('AB');
  });
}, 2000);
console.log(&quot;End...&quot;);
</code></pre>
<p>嵌套回调可以保证 <code>AB</code>一定在<code>A</code>之后输出。</p>
<pre><code>Start...
End...
A
AB
</code></pre>
<p>回调函数是Javascript异步编程最基本的编写方式，但是容易遇到回调地狱的问题。所谓回调地狱，其实就是回调嵌套的太多，导致了代码难以阅读和编写。这是http://callbackhell.com/ 给出的一个例子：</p>
<pre><code>fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})
</code></pre>
<h1 id="promise">Promise</h1>
<p>为了解决回调地狱的问题，Promise被囊括到ES6中。Promise解决回调地狱问题的核心思想是：</p>
<ol>
<li>将异步操作的定义和对结果的处理分开来写</li>
<li>对结果的处理可以串联</li>
</ol>
<p>有点抽象，我们来看一个具体的例子。</p>
<pre><code>console.log(&quot;Start...&quot;);
let waitOneSecond = new Promise(function(resolve, reject) {
  setTimeout(() =&gt; {
    let data = 1;
    resolve(data);
  }, 1000);
});
let waitTenSeconds = new Promise(function(resolve, reject) {
  setTimeout(() =&gt; {
    let data = 10;
    resolve(data);
  }, 10000);
});
console.log(&quot;Async operation registered...&quot;);

waitOneSecond
  .then(data =&gt; {
    console.log(`first output: ${data}`);
    return waitTenSeconds;
  })
  .then(data =&gt; {
    console.log(`second output: ${data}`);
  });

console.log(&quot;End...&quot;);
</code></pre>
<p>输出如下：</p>
<pre><code>Start...
Async operation registered...
End...
first output: 1
second output: 10
</code></pre>
<p>上面的代码首先定义了两个异步操作：waitOneSecond和waitTenSeconds。分别是等待1秒和10秒和把1和10传给处理函数去处理。直到<code>console.log(&quot;Async operation registered...&quot;);</code>语句，两个异步操作都还没有开始。当执行到waitOneSecond.then时，异步操作才开始进行，主程序继续执行，输出了<code>End...</code>，1秒之后第一个then中注册的处理函数开始执行，输出了数字1，然后第二个异步操作waitTenSenconds.then开始执行，10秒后处理函数输出了数字10.</p>
<p>由此可以看到，两个异步操作的处理同样是先后执行，类似于上文例子中先打印<code>A</code>，后打印<code>AB</code>，引入Promise后就避免了嵌套回调，两个then函数调用串联起来，从而也就解决了回调地狱的问题。需要注意的是，要想将两个Promise串联起来的前提是，第一个Promise的处理函数必须返回一个Promise，如例子中的<code>return waitTenSeconds;</code></p>
<p>除了解决回调地狱的问题，将异步操作定义和结果处理分开之后，我们可以更加灵活地处理多个异步操作。比如说，</p>
<pre><code>const promise1 = Promise.resolve(3);
const promise2 = 42;
const promise3 = new Promise(function(resolve, reject) {
  setTimeout(resolve, 100, 'foo');
});

Promise.all([promise1, promise2, promise3]).then(function(values) {
  console.log(values);
});
// expected output: Array [3, 42, &quot;foo&quot;]
</code></pre>
<p>promise1, promise2, promise3将会一起执行，如果都成功，我们可以在then函数中对所有的结果一起进行处理。</p>
<p>再例如：</p>
<pre><code>const promise1 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 500, 'one');
});

const promise2 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 100, 'two');
});

Promise.any([promise1, promise2]).then(function(value) {
  console.log(value);
  // Both resolve, but promise2 is faster
});
// expected output: &quot;two&quot;
</code></pre>
<p>如果promise1和promise2有一个已经完成(无论成功或者失败)，就只处理这个已经完成的异步操作。</p>
<h1 id="asyncawait">async/await</h1>
<p>ES6引入了迭代器和生成器，yield可以让程序暂停，而迭代器中的next()又可以程序恢复运行，利用这一点，Javascript便可以让主程序等待异步操作的完成。这对于习惯其他不使用异步编程语言(例如C语言)的同学来说就非常亲切了。而async/await正是利用迭代器和生成器编写异步函数的语法糖。例如：</p>
<pre><code>let waitTenSeconds = new Promise(function(resolve, reject) {
  setTimeout(() =&gt; {
    let data = 10;
    resolve(data);
  }, 10000);
});

async function asyncFunc() {
  console.log(&quot;Start...&quot;);
  await waitTenSeconds.then(data =&gt; {
    console.log(data);
  });
  console.log(&quot;End...&quot;);
}

asyncFunc();
</code></pre>
<p>如果asyncFunc不是async/await函数的话，输出结果应该是:</p>
<pre><code>Start...
End...
10
</code></pre>
<p>因为asyncFunc是异步操作，主程序会先打印<code>End...</code>，10秒之后才会打印<code>10</code>。而把asyncFunc改造为异步函数(即加了async关键字)之后，await关键字会让主程序等待waitTenSeconds异步操作执行完成之后才继续运行，所以输出结果是：</p>
<pre><code>Start...
10
End...
</code></pre>
<p>所以，async函数的写法其实更像是同步函数。值得注意的是，这样的写法虽然更加直观明了，但Javascript的性能主要是靠异步操作来提升的，如果没有必要，是不建议使用await来等待的。</p>
<p>async/await语法如下：</p>
<ul>
<li>需要在要异步函数前加上关键字async</li>
<li>await只能用于async函数中</li>
<li>async函数总是返回一个Promise</li>
</ul>
<h1 id="小结">小结</h1>
<p>随着Javascript语言的发展，异步编程的写法越来越简单明了，越来越灵活多样，但无论怎么变化，回调函数是Javascript实现异步操作最基本的语法，类似于中断机制的异步原理始终未变。无论技术如何发展，如何变化，但万变不离其宗，基本原理始终未变。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sass 概要]]></title>
        <id>https://sanmuny.github.io/post/sass-e6-a6-82-e8-a6-81/</id>
        <link href="https://sanmuny.github.io/post/sass-e6-a6-82-e8-a6-81/">
        </link>
        <updated>2019-06-18T06:51:52.000Z</updated>
        <content type="html"><![CDATA[<p>前端开发中最大的坑之一莫过于写css，流水账式的写法让众多码农们头痛不已。好在有了sass，写css不再死板。sass对css的增强如下：</p>
<h3 id="宏定义">宏定义</h3>
<p>宏定义的优点在于一处定义，多处使用，需要修改的时候只需要修改定义的地方即可。虽然sass没有明确的说明，但其实以下几种语法与C语言中的宏定义非常类似：</p>
<ol>
<li>
<p>变量 sass中的变量适用于替换css中参数的值。例如：</p>
<p>scss:</p>
<p>$basic-margin: &quot;10px 20px&quot;;</p>
<p>#box01 {<br>
margin: $basic-margin;<br>
}</p>
<p>#box02 {<br>
margin: $basic-margin;<br>
}</p>
<p>css:</p>
<p>#box01 {<br>
margin: &quot;10px 20px&quot;;<br>
}</p>
<p>#box02 {<br>
margin: &quot;10px 20px&quot;;<br>
}</p>
<p>sass允许根据变量，选择性的输出css，类似于开关，例如：</p>
<p>scss:</p>
<p>$rounded-corners: false;</p>
<p>.button {<br>
border: 1px solid black;<br>
border-radius: if($rounded-corners, 5px, null);<br>
}</p>
<p>css:</p>
<p>.button {<br>
border: 1px solid black;<br>
}</p>
<p>sass 也允许在子模块中给变量设置默认值，引用的时候可以再重新定义变量的值</p>
<p>_module.scss:</p>
<p>$userColor: red !default;</p>
<p>.bass {<br>
padding: 0 20px;<br>
color: $userColor;<br>
}</p>
<p>test.scss:</p>
<p>$userColor: black;<br>
@import &quot;module&quot;;</p>
<p>test.css:</p>
<p>.bass {<br>
padding: 0 20px;<br>
color: black;<br>
}</p>
<p>test.scss:</p>
<p>@import &quot;module&quot;;</p>
<p>test.css<br>
.bass {<br>
padding: 0 20px;<br>
color: red;<br>
}</p>
<p>使用!global可以在局部环境中设置全局变量的值，例如：</p>
<p>test.scss:</p>
<p>$color: red;</p>
<p>.text {<br>
$color: black !global;<br>
}</p>
<p>.box {<br>
color: $color;<br>
}</p>
<p>test.css:</p>
<p>.box {<br>
color: black;<br>
}</p>
</li>
<li>
<p>mixin sass中的mixin类似于支持参数的代码片段，可以很方便的将一段常用的代码片段插入到css规则中去，例如：</p>
<p>scss:</p>
<p>@mixin normal-font($fontfamily) {<br>
font-size: 18px;<br>
font-family: $fontfamily;<br>
}</p>
<p>.box {<br>
width: 200px;<br>
height: 200px;<br>
@include normal-font(&quot;IBM Plex Sans&quot;);<br>
}</p>
<p>css:</p>
<p>.box {<br>
width: 200px;<br>
height: 200px;<br>
font-size: 18px;<br>
font-family: &quot;IBM Plex Sans&quot;;<br>
}</p>
</li>
<li>
<p>扩展与继承 sass中的扩展相当于不带参数的代码片段，适用于同一组件的不同状态，语法如下：</p>
<p>scss:</p>
<p>%message-shared {<br>
border: 1px solid #ccc;<br>
padding: 10px;<br>
color: #333;<br>
}</p>
<p>.message {<br>
@extend %message-shared;<br>
}</p>
<p>.success {<br>
@extend %message-shared;<br>
border-color: green;<br>
}</p>
<p>.error {<br>
@extend %message-shared;<br>
border-color: red;<br>
}</p>
<p>.warning {<br>
@extend %message-shared;<br>
border-color: yellow;<br>
}</p>
<p>css:</p>
<p>.warning, .error, .success, .message {<br>
border: 1px solid #ccc;<br>
padding: 10px;<br>
color: #333;<br>
}</p>
<p>.success {<br>
border-color: green;<br>
}</p>
<p>.error {<br>
border-color: red;<br>
}</p>
<p>.warning {<br>
border-color: yellow;<br>
}</p>
<p></p>
</li>
</ol>
<h3 id="模块化">模块化</h3>
<p>sass也借鉴了编程语言中的模块化思想，允许文件引入。以下划线开头的文件类似于子模块，不会被被sass编译为css，只能被其他scss文件引用。例如：</p>
<p>_module.scss:</p>
<p>.bass {<br>
padding: 0 20px;<br>
}</p>
<p>test.scss:</p>
<p>@import &quot;module&quot;;</p>
<p>$basic-margin: &quot;10px 20px&quot;;</p>
<p>#box01 {<br>
margin: $basic-margin;<br>
}</p>
<p>#box02 {<br>
margin: $basic-margin;<br>
}</p>
<p>test.css:</p>
<p>.bass {<br>
padding: 0 20px;<br>
}</p>
<p>#box01 {<br>
margin: &quot;10px 20px&quot;;<br>
}</p>
<p>#box02 {<br>
margin: &quot;10px 20px&quot;;<br>
}</p>
<h3 id="语法简化">语法简化</h3>
<p>scss也对css的语法做了一些简化，比如说：</p>
<ol>
<li>
<p>嵌套 写scss子元素的规则不再另起一条规则，只需要嵌套在父元素中的规则中即可，例如：</p>
<p>scss:</p>
<p>$basic-margin: &quot;10px 20px&quot;;</p>
<p>.bss {<br>
margin: $basic-margin;<br>
#dash {<br>
margin-top: 20px;<br>
padding-top: 20px;<br>
}<br>
.dash {<br>
margin-top: 20px;<br>
margin-bottom: 20px;<br>
}<br>
}</p>
<p>css:</p>
<p>.bss {<br>
margin: &quot;10px 20px&quot;;<br>
}<br>
.bss #dash {<br>
margin-top: 20px;<br>
padding-top: 20px;<br>
}<br>
.bss .dash {<br>
margin-top: 20px;<br>
margin-bottom: 20px;<br>
}</p>
<p>另一种方式的嵌套：</p>
<p>scss：</p>
<p>.box {<br>
margin: {<br>
top: 20px;<br>
bottom: 10px;<br>
right: 10px;<br>
left: 20px;<br>
}<br>
}</p>
<p>css:</p>
<p>.box {<br>
margin-top: 20px;<br>
margin-bottom: 10px;<br>
margin-right: 10px;<br>
margin-left: 20px;<br>
}</p>
</li>
</ol>
<h3 id="可编程化">可编程化</h3>
<p>sass也做了一些工作让css更像一门编程语言而不是一遍作文。其中包括：</p>
<ol>
<li>
<p>支持运算 css是不支持运算的，而在scss中可以做一些简单的运算，例如：</p>
<p>scss:</p>
<p>.box {<br>
width: 100px / 200px * 100%;<br>
}</p>
<p>css:</p>
<p>.box {<br>
width: 50%;<br>
}</p>
</li>
<li>
<p>数值类型 scss中的值分为以下几种类型：</p>
<ul>
<li>数字，例如： 20, 20px</li>
<li>字符串，例如：&quot;IBM Plex Sans&quot;, bold</li>
<li>颜色值，例如：#ffffff, blue</li>
<li>布尔值, true, false</li>
<li>列表，例如：0 20px 30px 40px</li>
<li>字典，例如：(&quot;background&quot;: red, &quot;foreground&quot;: pink)</li>
</ul>
</li>
<li>
<p>操作符 scss中的操作符包括：</p>
<ul>
<li>== , !=  : 判断两个值是否相等/不相等</li>
<li>+ - * / %</li>
<li>&lt; &lt;= &gt; &gt;=</li>
<li>and or not</li>
<li>+ - / 可用于字符串拼接</li>
<li>() 用于优先级设定</li>
<li>&amp;父元素选择器</li>
<li>#{} 可以将sass表达式插入到css的文本中</li>
</ul>
</li>
<li>
<p>代码注释</p>
<ul>
<li>// 单行注释，不会编译到css中</li>
<li>/**/多行注释，一般会被编译进css</li>
<li>压缩模式下，多行注释不会被编译进css，除非以/*!开头</li>
<li>///为文档注释，不会被编译到css中，会被sassdoc工具使用，生成sass的文档</li>
</ul>
</li>
<li>
<p>函数 scss中的函数主要用于数值计算，例如：</p>
<p>scss:</p>
<p>@function pow($base, $exponent) {<br>
$result: 1;<br>
@for $_ from 1 through $exponent {<br>
$result: $result * $base;<br>
}<br>
@return $result;<br>
}</p>
<p>.sidebar {<br>
float: left;<br>
margin-left: pow(4, 3) * 1px;<br>
}</p>
<p>css:</p>
<p>.sidebar {<br>
float: left;<br>
margin-left: 64px;<br>
}</p>
<p>Sass中的内建函数详见 <a href="https://sass-lang.com/documentation/functions">https://sass-lang.com/documentation/functions</a></p>
</li>
<li>
<p>流程控制</p>
<ul>
<li>
<p>分支 @if , @else, @else if 例如：</p>
<p>scss:</p>
<p>@mixin triangle($color, $size, $direction) {<br>
display: block;<br>
height: 0;<br>
width: 0;<br>
border: $size/2 solid transparent;</p>
<p>@if $direction == up {<br>
border-bottom-color: $color;<br>
} @else if $direction == down {<br>
border-top-color: $color;<br>
} @else if $direction == left {<br>
border-right-color: $color;<br>
} @else if $direction == right {<br>
border-left-color: <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 10: color;
  }̲ @else {
    @e…'>color;
  } @else {
    @error &quot;wrong direction: #{</span>direction}&quot;;<br>
}<br>
}</p>
<p>.next {<br>
@include triangle(green, 20px, right);<br>
}</p>
<p>css:</p>
<p>.next {<br>
display: block;<br>
height: 0;<br>
width: 0;<br>
border: 10px solid transparent;<br>
border-left-color: green;<br>
}</p>
</li>
<li>
<p>循环 @each @for @while 例如：</p>
<p>scss:</p>
<p>$sizes: 40px, 50px, 80px;</p>
<p>@each $size in <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;#&#039; at position 17: …izes {
  .icon-#̲{'>sizes {
  .icon-#{</span>size} {<br>
font-size: $size;<br>
height: $size;<br>
width: $size;<br>
}<br>
}</p>
<p>css:</p>
<p>.icon-40px {<br>
font-size: 40px;<br>
height: 40px;<br>
width: 40px;<br>
}</p>
<p>.icon-50px {<br>
font-size: 50px;<br>
height: 50px;<br>
width: 50px;<br>
}</p>
<p>.icon-80px {<br>
font-size: 80px;<br>
height: 80px;<br>
width: 80px;<br>
}</p>
<p>scss:<br>
$base-color: #036;</p>
<p>@for <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;#&#039; at position 42: …nth-child(3n + #̲{'>i from 1 through 3 {
  ul:nth-child(3n + #{</span>i}) {<br>
background-color: lighten($base-color, $i * 5%);<br>
}<br>
}</p>
<p>css:</p>
<p>ul:nth-child(3n + 1) {<br>
background-color: #004080;<br>
}</p>
<p>ul:nth-child(3n + 2) {<br>
background-color: #004d99;<br>
}</p>
<p>ul:nth-child(3n + 3) {<br>
background-color: #0059b3;<br>
}</p>
<p>scss:<br>
@function scale-below($value, $base, $ratio: 1.618) {<br>
@while $value &gt; $base {<br>
$value: $value / $ratio;<br>
}<br>
@return $value;<br>
}</p>
<p>$normal-font-size: 16px;<br>
sup {<br>
font-size: scale-below(20px, 16px);<br>
}</p>
<p>css:<br>
sup {<br>
font-size: 12.36094px;<br>
}</p>
</li>
</ul>
</li>
<li>
<p>数值类型 sass中的数值类型包括以下几种：数值，字符串，颜色，List, Map，布尔值，null及函数</p>
<ul>
<li>
<p>数值包含数字和单位，sass的强大之处在于支持带单位的运算，例如：</p>
<p>@debug 1in + 6px; // 102px or 1.0625in</p>
</li>
<li>
<p>list和map的用法举例：</p>
<p>$prefixes-by-browser: (&quot;firefox&quot;: moz, &quot;safari&quot;: webkit, &quot;ie&quot;: ms);</p>
<p>@function prefixes-for-browsers($browsers) {<br>
$prefixes: ();<br>
@each $browser in $browsers {<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mi>i</mi><mi>x</mi><mi>e</mi><mi>s</mi><mo>:</mo><mi>a</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mo>(</mo></mrow><annotation encoding="application/x-tex">prefixes: append(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span></span></span></span>prefixes, map-get($prefixes-by-browser, $browser));<br>
}<br>
@return $prefixes;<br>
}</p>
<p>@debug prefixes-for-browsers(&quot;firefox&quot; &quot;ie&quot;); // moz ms</p>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[获取隐藏元素的宽度]]></title>
        <id>https://sanmuny.github.io/post/e8-8e-b7-e5-8f-96-e9-9a-90-e8-97-8f-e5-85-83-e7-b4-a0-e7-9a-84-e5-ae-bd-e5-ba-a6/</id>
        <link href="https://sanmuny.github.io/post/e8-8e-b7-e5-8f-96-e9-9a-90-e8-97-8f-e5-85-83-e7-b4-a0-e7-9a-84-e5-ae-bd-e5-ba-a6/">
        </link>
        <updated>2019-01-11T08:10:54.000Z</updated>
        <content type="html"><![CDATA[<h4 id="问题描述">问题描述</h4>
<p>如果DOM元素的fu'yu是被隐藏的(display: none)，那么无论使用DOM的接口，还是jquery的接口来获取该元素的宽度，得到的结果始终是0. 例如：</p>
<pre><code>&lt;div id=&quot;node&quot;&gt;
&lt;p&gt;
    hello world
&lt;/p&gt;
&lt;/div&gt;

#node {
    display: none;
}

alert($('#node p').width());
</code></pre>
<h4 id="解决方法">解决方法</h4>
<p>在过去元素的宽度之前，临时修改元素的display为block，获取之后再讲其设置回none 例如：</p>
<pre><code>function get_width(obj) {
var width = 0;
  obj.parent().css('display', 'block');
width = obj.width();
obj.parent().css('display', 'none');
return width;
}
alert(get_width($('#node p')));
</code></pre>
<h4 id="给jquery添加一个函数">给jquery添加一个函数</h4>
<p>参考<a href="https://stackoverflow.com/questions/1472303/jquery-get-width-of-element-when-not-visible-display-none">StackOverflow</a> ,Tim Banks给jquery添加了一个函数，用来获取隐藏元素的宽度和高度信息。</p>
<pre><code>(function ($) {
$.fn.getHiddenDimensions = function (include_margin) {
    var $item = this,
    props = { position: 'absolute', visibility: 'hidden', display: 'block' },
    dim = { width: 0, height: 0, innerWidth: 0, innerHeight: 0, outerWidth: 0, outerHeight: 0 },
    $hiddenParents = $item.parents().addBack().not(':visible'),
    includeMargin = (include\_margin == null) ? false : include\_margin;

    var oldProps = \[\];
    $hiddenParents.each(function () {
        var old = {};

        for (var name in props) {
            old\[name\] = this.style\[name\];
            this.style\[name\] = props\[name\];
        }

        oldProps.push(old);
    });

    dim.width = $item.width();
    dim.outerWidth = $item.outerWidth(includeMargin);
    dim.innerWidth = $item.innerWidth();
    dim.height = $item.height();
    dim.innerHeight = $item.innerHeight();
    dim.outerHeight = $item.outerHeight(includeMargin);

    $hiddenParents.each(function (i) {
        var old = oldProps\[i\];
        for (var name in props) {
            this.style\[name\] = old\[name\];
        }
    });

    return dim;
}
}($));
alert($('#node p').getHiddenDimensions().width);
</code></pre>
<p>在jsFiddle上试一试 <a href="https://jsfiddle.net/sen_wang/za7L1e8g/">-&gt;</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6: 模块编程]]></title>
        <id>https://sanmuny.github.io/post/es6-e6-a8-a1-e5-9d-97-e7-bc-96-e7-a8-8b/</id>
        <link href="https://sanmuny.github.io/post/es6-e6-a8-a1-e5-9d-97-e7-bc-96-e7-a8-8b/">
        </link>
        <updated>2019-01-08T13:34:59.000Z</updated>
        <content type="html"><![CDATA[<h4 id="javascript模块的限制">Javascript模块的限制</h4>
<ul>
<li>只能运行于严格模式</li>
<li>模块中的顶级作用域中的变量，不会被自动添加到全局作用域</li>
<li>顶级作用域的this为undefined</li>
</ul>
<h4 id="导出">导出</h4>
<p>如果想让模块中的变量、函数、类被其他模块使用，需要将其导出，导出的方法如下：</p>
<ul>
<li>export var color = &quot;red&quot;;</li>
<li>export function print_hello(){};</li>
<li>export { print_hello }</li>
<li>export { print_hello as printh };</li>
<li>export default function print_hello(){};</li>
<li>export default print_hello</li>
<li>export { print_hello as default}</li>
</ul>
<h4 id="导入">导入</h4>
<p>如果想使用其他模块中的变量、函数、类，需要将其导入。导入后的变量、类、函数为只读。导入的方法如下：</p>
<ul>
<li>import { color, print_hello } from &quot;./example.js&quot;;</li>
<li>import * as example from &quot;./example.js&quot;;  //example.color, example.print_hello</li>
<li>import { print_hello as printh } from &quot;./example.js&quot;;</li>
<li>import print_hello, { color } from &quot;./example.js&quot;; // print_hello 为默认导出的函数</li>
<li>import { default as printh } from &quot;./example.js&quot;;</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6：数组]]></title>
        <id>https://sanmuny.github.io/post/es6-ef-bc-9a-e6-95-b0-e7-bb-84/</id>
        <link href="https://sanmuny.github.io/post/es6-ef-bc-9a-e6-95-b0-e7-bb-84/">
        </link>
        <updated>2019-01-03T08:25:11.000Z</updated>
        <content type="html"><![CDATA[<h4 id="新增的静态方法">新增的静态方法</h4>
<p>Array.of() ：可以将传入的参数逐个传入数组，即使只有一个数值类型的参数，也会成为新数组的成员，而不是代表数组的长度 Array.from()：可以将类数组结构转化为数组，例如: Array.from(arguments). 利用Array.from()也可以转换原来的数组，例如：</p>
<pre><code>let trans_args = function() {
    let args = Array.from(arguments, (value)=&gt;value + 1);
    console.log(args);
}

trans_args(1, 2, 3);

$ node test.js 
[ 2, 3, 4 ]
</code></pre>
<h4 id="新增的普通方法">新增的普通方法</h4>
<p>find() 与findIndex()：传入一个回调函数来表明查找的条件，例如：</p>
<pre><code>&gt; let arr = [1, 2, 3, 4, 5];
undefined
&gt; arr.find((n)=&gt;n&gt;3);
4
&gt; arr.findIndex((n)=&gt;n&gt;3);
3
</code></pre>
<p>fill(value, start, end)：填充value到数组的start到end位置，不包括end. 例如：</p>
<pre><code>let arr = [1, 2, 3, 4, 5];
arr.fill(1, 1, 4);
[ 1, 1, 1, 1, 5 ]
</code></pre>
<p>copyWithin(toIndex, fromIndex, stopIndex): 从fromIndex开始复制元素到toIndex，遇到stopIndex停止，例如：</p>
<pre><code>&gt; let arr = [1, 2, 3, 4, 5]
undefined
&gt; arr.copyWithin(2, 0, 1);
[ 1, 2, 1, 4, 5 ]
</code></pre>
<h4 id="类型化数组">类型化数组</h4>
<p>javascript中的数组缓冲区类似于c的malloc，例如，可以用如下方法分配一个10个字节大小的内存区域：</p>
<pre><code>&gt; let bu = new ArrayBuffer(10);
undefined
&gt; bu.byteLength
10
</code></pre>
<p>可以使用slice(start, end)方法来对分配的内存进行切片。 要操作新分配的内存，需要使用DataView(buf, index, length)创建一个视图，例如：</p>
<pre><code>&gt; let buf = new ArrayBuffer(50);
&gt; let view = new DataView(buf, 0, 50);
</code></pre>
<p>获取视图的信息：</p>
<pre><code>&gt; view.buffer === buf;
true
&gt; view.byteOffset
0
&gt; view.byteLength
50
</code></pre>
<p>读写数据：</p>
<pre><code>&gt; view.setUint8(4, 233);
undefined
&gt; view.getUint8(4)
233</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6中的类]]></title>
        <id>https://sanmuny.github.io/post/es6-e4-b8-ad-e7-9a-84-e7-b1-bb/</id>
        <link href="https://sanmuny.github.io/post/es6-e4-b8-ad-e7-9a-84-e7-b1-bb/">
        </link>
        <updated>2019-01-02T09:43:54.000Z</updated>
        <content type="html"><![CDATA[<p>ES6中添加的class关键字其实并非真正的类，而是ES5用函数来模拟类的语法糖。在ES6中可以用如下的语法创建一个类：</p>
<pre><code>class Students {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    sayName() {
        console.log(this.name);
    }
    sayAge() {
        console.log(this.age);
    }
}

let st1 = new Students('sen', 18);
st1.sayName();
st1.sayAge();
</code></pre>
<p>使用ES6的class语法糖和ES5自定义的类还是有些区别的：</p>
<ul>
<li>类的声明不会被提升，类的实例化只能在类的声明之后</li>
<li>类声明中的代码只能运行在严格模式下</li>
<li>类中的方法是不可枚举的</li>
<li>实例化的时候必须加new关键字</li>
<li>在方法内部修改类名会抛出错误，但可以在外部修改类名</li>
</ul>
<p>下面的例子展示了如何在外部修改类名：</p>
<pre><code>class Students {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    sayName() {
        console.log(this.name);
    }
    sayAge() {
        console.log(this.age);
    }
}

let st1 = new Students('sen', 18);
st1.sayName();
st1.sayAge();

let Stu = Students;

let st2 = new Stu('sen', 18);
st2.sayName();
st2.sayAge();

console.log(st1 instanceof Students); //true
console.log(st2 instanceof Students); //true
console.log(st2 instanceof Stu); //true
console.log(st1 instanceof Stu); //true
</code></pre>
<h4 id="类中的访问器属性">类中的访问器属性</h4>
<p>可以使用get和set关键字来定义访问器属性，例如：</p>
<pre><code>class Students {
    constructor(name) {
        this.name = name;
    }
    get n() {
        return this.name;
    }
    set n(value) {
        this.name = value;
    }
}

let st1 = new Students('sen', 18);
console.log(st1.n);
st1.n = 'wang';
console.log(st1.n);
</code></pre>
<h4 id="需计算的属性名">需计算的属性名</h4>
<p>和其他需计算的名字一样，都是加上方括号，例如：</p>
<p>let propName = &quot;sayName&quot;;</p>
<pre><code>class Students {
    constructor(name) {
        this.name = name;
    }
    [propName]() {
        console.log(this.name);
    }
}

let st1 = new Students('sen');
st1.sayName();
</code></pre>
<h4 id="给类添加默认的生成器">给类添加默认的生成器</h4>
<p>可以利用Symbol来给类添加默认的生成器，如：</p>
<pre><code>class Collection {
    constructor() {
        this.items = [];
    }
    *[Symbol.iterator]() {
        yield *this.items.values();
    }
}

let col = new Collection();
col.items.push(1);
col.items.push(2);
col.items.push(3);
for( let i of col) {
    console.log(i);
}
</code></pre>
<h4 id="给类添加静态属性方法">给类添加静态属性/方法</h4>
<p>类的静态方法/属性只能通过类名来访问，而不能通过类的实例来访问，具体做法是在方法/属性定义前面加上static关键字，例如：</p>
<pre><code>class Students {
    constructor(name) {
        this.name = name;
    }
    static sayClassName() {
        console.log(&quot;Collection&quot;);
    }
}

Students.sayClassName();
let stu = new Students('sen');
stu.sayClassName(); // error
</code></pre>
<h4 id="类的继承">类的继承</h4>
<p>ES6引入了extends和super来实现类的继承，例如：</p>
<pre><code>class Rectangle {
    constructor(length, width) {
        this.length = length;
        this.width = width;
    }
    getArea() {
        return this.length * this.width;
    }
}

class Square extends Rectangle {
    constructor(length) {
        super(length, length);
    }
}

let sq = new Square(5);
console.log(sq.getArea());
</code></pre>
<p>使用super需要注意：</p>
<ul>
<li>super只能用在派生类中</li>
<li>在constructor里，super负责初始化this，所以必须在this使用之前调用</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6: 迭代器与生成器]]></title>
        <id>https://sanmuny.github.io/post/es6-e8-bf-ad-e4-bb-a3-e5-99-a8-e4-b8-8e-e7-94-9f-e6-88-90-e5-99-a8/</id>
        <link href="https://sanmuny.github.io/post/es6-e8-bf-ad-e4-bb-a3-e5-99-a8-e4-b8-8e-e7-94-9f-e6-88-90-e5-99-a8/">
        </link>
        <updated>2018-12-07T08:23:24.000Z</updated>
        <content type="html"><![CDATA[<h4 id="什么是迭代器">什么是迭代器？</h4>
<p>迭代器是一个对象，它拥有一个next方法，调用next方法会返回一个对象，该对象有两个属性值，value和done。每次调用next方法，返回的value表示可迭代对象中的下一个值，done表示迭代是否完成。根据此定义，可用下面的代码实现一个迭代器:</p>
<pre><code>let create_iter = function(items) {
    let i = 0;
    return {
        next: function() {
            let value, done;
            if (i &gt;= items.length) {
                value = null;
                done = true;
            } else {
                value = items\[i++\];
                done = false;
            }
            return {
                value: value,
                done: done
            }
        }
    }
}
</code></pre>
<h4 id="什么是生成器">什么是生成器？</h4>
<p>用来创建迭代器的函数称之为生成器，ES6为了简化生成器，引入了新的语法：</p>
<ul>
<li>在生成器函数前加*</li>
<li>使用yield关键字抛出下一个value</li>
</ul>
<p>引入新的语法后，生成器的代码可以简化为：</p>
<pre><code>let gen = function*(items) {
    for (let i = 0; i &lt; items.length; i++) {
        yield items\[i\];
    }
}
</code></pre>
<h4 id="举个栗子">举个栗子</h4>
<p>下面的代码比较了两种创建迭代器的方法：</p>
<pre><code>let create_iter = function(items) {
    let i = 0;
    return {
        next: function() {
            let value, done;
            if (i &gt;= items.length) {
                value = null;
                done = true;
            } else {
                value = items[i++];
                done = false;
            }
            return {
                value: value,
                done: done
            }
        }
    }
}

let gen = function*(items) {
    for (let i = 0; i &lt; items.length; i++) {
        yield items[i];
    }
}

let items = [1, 2, 3, 4, 5];

let it = gen(items);
console.log(it.next());
console.log(it.next());
console.log(it.next());
console.log(it.next());
console.log(it.next());
console.log(it.next());
</code></pre>
<p>输出结果：</p>
<pre><code>$ node test.js 
{ value: 1, done: false }
{ value: 2, done: false }
{ value: 3, done: false }
{ value: 4, done: false }
{ value: 5, done: false }
{ value: undefined, done: true }
{ value: undefined, done: true }
</code></pre>
<h4 id="生成器的表现形式">生成器的表现形式</h4>
<ul>
<li>function *my_generator(items) {}</li>
<li>let my_generator = function *(items) {}</li>
<li>let obj = {*my_generator(items){}};</li>
</ul>
<h4 id="可迭代对象">可迭代对象</h4>
<p>可迭代对象指的是包含Symbol.iterator属性的对象，数组、Set、Map、字符串都是可迭代对象，都有默认的迭代器。 可迭代对象可以与for-of配合使用，例如：</p>
<pre><code>let numbers = [1, 2, 3, 4, 5];
for (let num of numbers) {
    console.log(num);
}
</code></pre>
<p>可以用一下方法自定义一个可迭代对象：</p>
<pre><code>let colors = {
    items: [1, 2, 3, 4, 5],
    *[Symbol.iterator]() {
        for (let item of this.items) {
            yield item;
        }
    }
}
</code></pre>
<h4 id="内置迭代器">内置迭代器</h4>
<p>数组、Map和Set 都有一下三个内置的迭代器：</p>
<ul>
<li>entries(): 返回一个包含键值对(数组)的迭代器</li>
<li>values(): 返回一个只包含值的迭代器</li>
<li>keys(): 返回一个只包含键的迭代器</li>
</ul>
<p>对于数组来说，keys返回的是元素的下标，对于Set来说，返回的是元素的值，而对于Map来说，返回的是元素的key。</p>
<h4 id="给迭代器传入参数">给迭代器传入参数</h4>
<p>当调用next方法时，若传入参数，则该参数会替代上一次yield表达式的值，例如：</p>
<pre><code>let gen = function *() {
    let a = yield 1;
    let b = yield a + 1;
    yield b + 1;
}

let iter = gen();

console.log(iter.next());
console.log(iter.next(100));
console.log(iter.next(200));
console.log(iter.next());

执行结果：

$ node test.js 
{ value: 1, done: false }
{ value: 101, done: false }
{ value: 201, done: false }
{ value: undefined, done: true }

#### 生成器委托

也就是生成器的嵌套，例如：

let generator0 = function *() {
    yield 0;
    yield 1;
    yield 2;
}

let generator1 = function *() {
    yield 3;
    yield 4;
    yield 5;
}

let generator = function *() {
    yield *generator0();
    yield *generator1();
    yield 6;
}

let iter = generator();

console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单链表反转]]></title>
        <id>https://sanmuny.github.io/post/e5-8d-95-e9-93-be-e8-a1-a8-e5-8f-8d-e8-bd-ac/</id>
        <link href="https://sanmuny.github.io/post/e5-8d-95-e9-93-be-e8-a1-a8-e5-8f-8d-e8-bd-ac/">
        </link>
        <updated>2018-12-07T06:43:11.000Z</updated>
        <content type="html"><![CDATA[<h4 id="实现单链表反转的思路">实现单链表反转的思路</h4>
<p>实现单链表反转的难点在于，如果让当前节点的next指向前驱节点，那么链表就断了，所以解决的办法就是在进行反转操作之前用一个临时指针变量保存后继节点的地址。</p>
<h4 id="单链表反转的代码实现">单链表反转的代码实现</h4>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct LIST_NODE {
    int data;
    struct LIST_NODE* next;
} LIST_NODE;

void show\_list(LIST\_NODE *head) {
    LIST_NODE *p = head-&gt;next;

    while(p != NULL) {
        printf(&quot;%d &quot;, p-&gt;data);
        p = p-&gt;next;
    }
    printf(&quot;\\n&quot;);
}

void reverse\_list(LIST\_NODE *head) {
    LIST_NODE \*p, \*q, *tmp;
    p = head;
    q = p-&gt;next;

    while (q != NULL) {
        tmp = q-&gt;next;
        if (p == head) {
            q-&gt;next = NULL;
        } else {
            q-&gt;next = p;
        }
        p = q;
        q = tmp;
    }
    head-&gt;next = p;
}

int main(int argc, char **argv) {
    LIST_NODE head = {
        .data = 0,
        .next = NULL
    };
    int data;
    LIST_NODE *tail = &amp;head;
    while (1) {
        printf(&quot;Please input a number: (0 to stop input)\\n&quot;);
        scanf(&quot;%d&quot;, &amp;data);
        if (data == 0) {
            break;
        }
        LIST\_NODE *new\_node = malloc(sizeof(LIST_NODE));
        new_node-&gt;data = data;
        new_node-&gt;next = NULL;
        tail-&gt;next = new_node;
        tail = new_node;
    }
    show_list(&amp;head);
    reverse_list(&amp;head);
    show_list(&amp;head);
    return 0;
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[冒泡排序、插入法排序及选择排序]]></title>
        <id>https://sanmuny.github.io/post/e5-86-92-e6-b3-a1-e6-8e-92-e5-ba-8f-e3-80-81-e6-8f-92-e5-85-a5-e6-b3-95-e6-8e-92-e5-ba-8f-e5-8f-8a-e9-80-89-e6-8b-a9-e6-8e-92-e5-ba-8f/</id>
        <link href="https://sanmuny.github.io/post/e5-86-92-e6-b3-a1-e6-8e-92-e5-ba-8f-e3-80-81-e6-8f-92-e5-85-a5-e6-b3-95-e6-8e-92-e5-ba-8f-e5-8f-8a-e9-80-89-e6-8b-a9-e6-8e-92-e5-ba-8f/">
        </link>
        <updated>2018-11-22T07:51:02.000Z</updated>
        <content type="html"><![CDATA[<p>冒泡排序、插入法排序以及选择排序是排序算法中比较基础的三种，其平均时间复杂度都是O(n^2)。 <img src="https://static001.geekbang.org/resource/image/34/50/348604caaf0a1b1d7fee0512822f0e50.jpg" alt="" loading="lazy"></p>
<h3 id="原理介绍">原理介绍</h3>
<h4 id="冒泡排序">冒泡排序</h4>
<p>冒泡排序的步骤是：比较相邻两个数，看是否满足大小关系，如果不满足则交换这两个数，使他们满足大小关系，这样可以保证最大（最小）的数始终会向后流动，循环一次之后，最大（最小）的数就会被交换到数组的最后。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p>
<h4 id="插入法排序">插入法排序</h4>
<p>插入法排序的思路是：把数组分成两个部分：排好序的，和未排序的。开始的时候，数组的第一个元素会被当做拍好序的部分，对其余未排好序的数值进行迭代，将其插入到排好序的部分中合适的位置。</p>
<h4 id="选择法排序">选择法排序</h4>
<p>选择法排序和插入法排序类似，都是将数组分为排好序的和未排序的两个部分。不同的是，选择法排序每次迭代都会选择未排序部分中的最小（最大）值，将其插入到排好序部分的队首（队尾）。</p>
<h3 id="c语言实现">C语言实现</h3>
<p>需要实现四个函数， 第一个是打印数组，接下来三个函数分别实现三种排序算法：</p>
<ul>
<li>void print_arry(int *a, int len)</li>
<li>static inline void insertion_sort(int *a, int len)</li>
<li>static inline void bubble_sort(int *a, int len)</li>
<li>static inline void selection_sort(int *a, int len)</li>
</ul>
<p>main函数中，首先需要用户输入指定数目(#define LEN 10)的数值，如果用户输入-1则随机生成这些数值。然后需要用户输入排序算法。输入完成后打印排序前的数组，然后根据相应的排序算法进行排序，最后再打印出排序后的数组。代码如下：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;

#define LEN 10
#define NR_METHOD 3
#define RAND_RANGE 100

void print_arry(int *a, int len) {
    int i = 0;
    for (int i = 0; i &lt; len; i++) {
        printf(&quot;%d &quot;, a\[i\]);
    }
    printf(&quot;\\n&quot;);
}

static inline void insertion_sort(int *a, int len) {
    int tmp = 0;
    int i, j;
    for (i = 1; i &lt; len; i++) {
        tmp = a\[i\];
        for (j = i - 1; j &gt;= 0; j--) {
            if (a\[j\] &gt; tmp) {
                a\[j + 1\] = a\[j\];
            } else {
                break;
            }
        }
        a\[j + 1\] = tmp;
    }
}

static inline void bubble_sort(int *a, int len) {
    int i, j;
    int tmp;
    int swapped = 0;
    for (i = len - 1; i &gt;= 0; i--) {
        for (j = 0; j &lt; i; j++) {
            if (a\[j\] &gt; a\[j + 1\]) {
                tmp = a\[j\];
                a\[j\] = a\[j + 1\];
                a\[j + 1\] = tmp;
                swapped = 1;
            }
        }
        if (!swapped) {
            break;
        }
    }
}

static inline void selection_sort(int *a, int len) {
    int i, j, min, tmp;
    for (i = 0; i &lt; len -1; i++) {
        min = i;
        for (j = i + 1; j &lt; len; j++) {
            if(a\[j\] &lt; a\[min\]) {
                min = j;
            }
        }
        if (min != i) {
            tmp = a\[min\];
            a\[min\] = a\[i\];
            a\[i\] = tmp;
        }
    }
}

int main(int argc, char **argv) {
    srand(time(NULL));

    int a\[LEN\];
    int data;

    for (int i = 0; i &lt; LEN; i++) {
        printf(&quot;Please input a number: %d left: (-1 for random numbers)&quot;, LEN - i);
        scanf(&quot;%d&quot;, &amp;data);
        if(data != -1) {
            a\[i\] = data;
        } else {
            for (int j = 0; j &lt; LEN; j++) {
                a\[j\] = rand() % RAND_RANGE;
            }
            break;
        }
    }

    while (1) {
        printf(&quot;Please select a sort method:\\n&quot;);
        printf(&quot;0: Insertion sort\\n&quot;);
        printf(&quot;1: Bubble sort \\n&quot;);
        printf(&quot;2: Selection sort \\n&quot;);
        scanf(&quot;%d&quot;, &amp;data);
        if(data &gt;= 0 &amp;&amp; data &lt; NR_METHOD) {
            break;
        } else {
            printf(&quot;Please input a valid number!\\n&quot;);
        }
    }

    printf(&quot;Original Array: \\n&quot;);
    print_arry(a, LEN);

    switch(data) {
        case 0:
        printf(&quot;You selected insertion sort\\n&quot;);
        insertion_sort(a, LEN);
        break;
        case 1:
        printf(&quot;You selected bubble sort\\n&quot;);
        bubble_sort(a, LEN);
        break;
        case 2:
        printf(&quot;You selected selection sort\\n&quot;);
        selection_sort(a, LEN);
        break;
    }

    printf(&quot;Sorted Array: \\n&quot;);
    print_arry(a, LEN);

    return 0;
}</code></pre>
]]></content>
    </entry>
</feed>