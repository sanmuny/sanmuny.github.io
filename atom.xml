<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sanmuny.github.io</id>
    <title>三木的技术博客</title>
    <updated>2021-06-11T06:16:31.463Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sanmuny.github.io"/>
    <link rel="self" href="https://sanmuny.github.io/atom.xml"/>
    <subtitle>Honesty and diligence should be your eternal mates.</subtitle>
    <logo>https://sanmuny.github.io/images/avatar.png</logo>
    <icon>https://sanmuny.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 三木的技术博客</rights>
    <entry>
        <title type="html"><![CDATA[Javascript中的异步编程]]></title>
        <id>https://sanmuny.github.io/post/OecN7NV6c/</id>
        <link href="https://sanmuny.github.io/post/OecN7NV6c/">
        </link>
        <updated>2020-01-15T08:15:37.000Z</updated>
        <summary type="html"><![CDATA[<p>Javascript最开始是用于浏览器中的前端编程语言。Javascript是单线程的，为了能及时响应用户操作，javascript对耗时操作（如Ajax请求、本地文件读取等)的处理是异步进行的，也即是所谓的异步编程。除了快速响应用户操作之外，另外一个让javascript采用异步方式的原因是，程序无法预知用户会进行哪些操作。比如说程序无法提前知道用户是点“取消”按钮还是“确定”按钮。所以，Javascript采用了事件注册的方式来处理这个问题。在程序编写时，可以给用户点击“取消”按钮和“确认”按钮注册不同的回调函数，这样当用户点击不同的按钮时，不同的回调函数会被执行。本文从回调函数开始，介绍了Promise、async/await几种Javascript主要的异步编程方式。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Javascript最开始是用于浏览器中的前端编程语言。Javascript是单线程的，为了能及时响应用户操作，javascript对耗时操作（如Ajax请求、本地文件读取等)的处理是异步进行的，也即是所谓的异步编程。除了快速响应用户操作之外，另外一个让javascript采用异步方式的原因是，程序无法预知用户会进行哪些操作。比如说程序无法提前知道用户是点“取消”按钮还是“确定”按钮。所以，Javascript采用了事件注册的方式来处理这个问题。在程序编写时，可以给用户点击“取消”按钮和“确认”按钮注册不同的回调函数，这样当用户点击不同的按钮时，不同的回调函数会被执行。本文从回调函数开始，介绍了Promise、async/await几种Javascript主要的异步编程方式。</p>
<!-- more -->
<h1 id="异步编程和回调函数">异步编程和回调函数</h1>
<p>无论是Ajax请求，还是事件处理，Javascript都是通过回调函数来完成的。谈及异步编程和回调函数，可以回想一下操作系统中的中断及中断处理程序。由于CPU的速度比外设快出许多，为了提高CPU的处理效率，计算机系统引入了中断的概念，外设在读写数据的时候，CPU可以忙别的事情，等到外设读写完数据后，会给CPU发一个中断信号，CPU就可以来执行已经注册好的、相应的中断处理程序。Javascript中的回调函数和中断处理程序都是类似的原理。</p>
<p>先来看一个异步的例子：</p>
<pre><code>console.log(&quot;Start...&quot;);
setTimeout(()=&gt;{
  console.log(&quot;in progress&quot;);
}, 2000);
console.log(&quot;End...&quot;);
</code></pre>
<p>如果是同步的话，输出的顺序应该是：</p>
<pre><code>Start...
in progress
End...
</code></pre>
<p>然而真实的输出结果却是这样的：</p>
<pre><code>Start...
End...
in progress
</code></pre>
<p>原因在于setTimeout中的第一个参数，箭头函数(即上文所说的回调函数)是异步执行的。setTimeout相当于注册一个回调函数，该回调函数在2000毫秒(2秒)之后运行。由于是异步的，主程序并不会等到两秒之后才跑setTimeout后面的代码，而是立即执行，所以先输出了<code>End...</code>，2秒之后，注册的回调函数运行了，输出了<code>in progress</code>。</p>
<p>举一反三，Ajax请求、事件处理都是类似的。比如：</p>
<pre><code>$.ajax({
  url: url,
  data: data,
  success: ()=&gt;{},
  dataType: dataType
});

$('#mydiv').on('click', ()=&gt;{})
</code></pre>
<p>其中的两个箭头函数就是回调函数。</p>
<p>当后面的异步操作依赖于前面异步操作的结果时，就需要在回调函数中嵌套回调函数，例如：</p>
<pre><code>console.log(&quot;Start...&quot;);
setTimeout(()=&gt;{
  console.log('A');
  setTimeout(()=&gt;{
    console.log('AB');
  });
}, 2000);
console.log(&quot;End...&quot;);
</code></pre>
<p>嵌套回调可以保证 <code>AB</code>一定在<code>A</code>之后输出。</p>
<pre><code>Start...
End...
A
AB
</code></pre>
<p>回调函数是Javascript异步编程最基本的编写方式，但是容易遇到回调地狱的问题。所谓回调地狱，其实就是回调嵌套的太多，导致了代码难以阅读和编写。这是http://callbackhell.com/ 给出的一个例子：</p>
<pre><code>fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})
</code></pre>
<h1 id="promise">Promise</h1>
<p>为了解决回调地狱的问题，Promise被囊括到ES6中。Promise解决回调地狱问题的核心思想是：</p>
<ol>
<li>将异步操作的定义和对结果的处理分开来写</li>
<li>对结果的处理可以串联</li>
</ol>
<p>有点抽象，我们来看一个具体的例子。</p>
<pre><code>console.log(&quot;Start...&quot;);
let waitOneSecond = new Promise(function(resolve, reject) {
  setTimeout(() =&gt; {
    let data = 1;
    resolve(data);
  }, 1000);
});
let waitTenSeconds = new Promise(function(resolve, reject) {
  setTimeout(() =&gt; {
    let data = 10;
    resolve(data);
  }, 10000);
});
console.log(&quot;Async operation registered...&quot;);

waitOneSecond
  .then(data =&gt; {
    console.log(`first output: ${data}`);
    return waitTenSeconds;
  })
  .then(data =&gt; {
    console.log(`second output: ${data}`);
  });

console.log(&quot;End...&quot;);
</code></pre>
<p>输出如下：</p>
<pre><code>Start...
Async operation registered...
End...
first output: 1
second output: 10
</code></pre>
<p>上面的代码首先定义了两个异步操作：waitOneSecond和waitTenSeconds。分别是等待1秒和10秒和把1和10传给处理函数去处理。直到<code>console.log(&quot;Async operation registered...&quot;);</code>语句，两个异步操作都还没有开始。当执行到waitOneSecond.then时，异步操作才开始进行，主程序继续执行，输出了<code>End...</code>，1秒之后第一个then中注册的处理函数开始执行，输出了数字1，然后第二个异步操作waitTenSenconds.then开始执行，10秒后处理函数输出了数字10.</p>
<p>由此可以看到，两个异步操作的处理同样是先后执行，类似于上文例子中先打印<code>A</code>，后打印<code>AB</code>，引入Promise后就避免了嵌套回调，两个then函数调用串联起来，从而也就解决了回调地狱的问题。需要注意的是，要想将两个Promise串联起来的前提是，第一个Promise的处理函数必须返回一个Promise，如例子中的<code>return waitTenSeconds;</code></p>
<p>除了解决回调地狱的问题，将异步操作定义和结果处理分开之后，我们可以更加灵活地处理多个异步操作。比如说，</p>
<pre><code>const promise1 = Promise.resolve(3);
const promise2 = 42;
const promise3 = new Promise(function(resolve, reject) {
  setTimeout(resolve, 100, 'foo');
});

Promise.all([promise1, promise2, promise3]).then(function(values) {
  console.log(values);
});
// expected output: Array [3, 42, &quot;foo&quot;]
</code></pre>
<p>promise1, promise2, promise3将会一起执行，如果都成功，我们可以在then函数中对所有的结果一起进行处理。</p>
<p>再例如：</p>
<pre><code>const promise1 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 500, 'one');
});

const promise2 = new Promise(function(resolve, reject) {
    setTimeout(resolve, 100, 'two');
});

Promise.any([promise1, promise2]).then(function(value) {
  console.log(value);
  // Both resolve, but promise2 is faster
});
// expected output: &quot;two&quot;
</code></pre>
<p>如果promise1和promise2有一个已经完成(无论成功或者失败)，就只处理这个已经完成的异步操作。</p>
<h1 id="asyncawait">async/await</h1>
<p>ES6引入了迭代器和生成器，yield可以让程序暂停，而迭代器中的next()又可以程序恢复运行，利用这一点，Javascript便可以让主程序等待异步操作的完成。这对于习惯其他不使用异步编程语言(例如C语言)的同学来说就非常亲切了。而async/await正是利用迭代器和生成器编写异步函数的语法糖。例如：</p>
<pre><code>let waitTenSeconds = new Promise(function(resolve, reject) {
  setTimeout(() =&gt; {
    let data = 10;
    resolve(data);
  }, 10000);
});

async function asyncFunc() {
  console.log(&quot;Start...&quot;);
  await waitTenSeconds.then(data =&gt; {
    console.log(data);
  });
  console.log(&quot;End...&quot;);
}

asyncFunc();
</code></pre>
<p>如果asyncFunc不是async/await函数的话，输出结果应该是:</p>
<pre><code>Start...
End...
10
</code></pre>
<p>因为asyncFunc是异步操作，主程序会先打印<code>End...</code>，10秒之后才会打印<code>10</code>。而把asyncFunc改造为异步函数(即加了async关键字)之后，await关键字会让主程序等待waitTenSeconds异步操作执行完成之后才继续运行，所以输出结果是：</p>
<pre><code>Start...
10
End...
</code></pre>
<p>所以，async函数的写法其实更像是同步函数。值得注意的是，这样的写法虽然更加直观明了，但Javascript的性能主要是靠异步操作来提升的，如果没有必要，是不建议使用await来等待的。</p>
<p>async/await语法如下：</p>
<ul>
<li>需要在要异步函数前加上关键字async</li>
<li>await只能用于async函数中</li>
<li>async函数总是返回一个Promise</li>
</ul>
<h1 id="小结">小结</h1>
<p>随着Javascript语言的发展，异步编程的写法越来越简单明了，越来越灵活多样，但无论怎么变化，回调函数是Javascript实现异步操作最基本的语法，类似于中断机制的异步原理始终未变。无论技术如何发展，如何变化，但万变不离其宗，基本原理始终未变。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sass 概要]]></title>
        <id>https://sanmuny.github.io/post/sass-e6-a6-82-e8-a6-81/</id>
        <link href="https://sanmuny.github.io/post/sass-e6-a6-82-e8-a6-81/">
        </link>
        <updated>2019-06-18T06:51:52.000Z</updated>
        <content type="html"><![CDATA[<p>前端开发中最大的坑之一莫过于写css，流水账式的写法让众多码农们头痛不已。好在有了sass，写css不再死板。sass对css的增强如下：</p>
<h3 id="宏定义">宏定义</h3>
<p>宏定义的优点在于一处定义，多处使用，需要修改的时候只需要修改定义的地方即可。虽然sass没有明确的说明，但其实以下几种语法与C语言中的宏定义非常类似：</p>
<ol>
<li>
<p>变量 sass中的变量适用于替换css中参数的值。例如：</p>
<p>scss:</p>
<p>$basic-margin: &quot;10px 20px&quot;;</p>
<p>#box01 {<br>
margin: $basic-margin;<br>
}</p>
<p>#box02 {<br>
margin: $basic-margin;<br>
}</p>
<p>css:</p>
<p>#box01 {<br>
margin: &quot;10px 20px&quot;;<br>
}</p>
<p>#box02 {<br>
margin: &quot;10px 20px&quot;;<br>
}</p>
<p>sass允许根据变量，选择性的输出css，类似于开关，例如：</p>
<p>scss:</p>
<p>$rounded-corners: false;</p>
<p>.button {<br>
border: 1px solid black;<br>
border-radius: if($rounded-corners, 5px, null);<br>
}</p>
<p>css:</p>
<p>.button {<br>
border: 1px solid black;<br>
}</p>
<p>sass 也允许在子模块中给变量设置默认值，引用的时候可以再重新定义变量的值</p>
<p>_module.scss:</p>
<p>$userColor: red !default;</p>
<p>.bass {<br>
padding: 0 20px;<br>
color: $userColor;<br>
}</p>
<p>test.scss:</p>
<p>$userColor: black;<br>
@import &quot;module&quot;;</p>
<p>test.css:</p>
<p>.bass {<br>
padding: 0 20px;<br>
color: black;<br>
}</p>
<p>test.scss:</p>
<p>@import &quot;module&quot;;</p>
<p>test.css<br>
.bass {<br>
padding: 0 20px;<br>
color: red;<br>
}</p>
<p>使用!global可以在局部环境中设置全局变量的值，例如：</p>
<p>test.scss:</p>
<p>$color: red;</p>
<p>.text {<br>
$color: black !global;<br>
}</p>
<p>.box {<br>
color: $color;<br>
}</p>
<p>test.css:</p>
<p>.box {<br>
color: black;<br>
}</p>
</li>
<li>
<p>mixin sass中的mixin类似于支持参数的代码片段，可以很方便的将一段常用的代码片段插入到css规则中去，例如：</p>
<p>scss:</p>
<p>@mixin normal-font($fontfamily) {<br>
font-size: 18px;<br>
font-family: $fontfamily;<br>
}</p>
<p>.box {<br>
width: 200px;<br>
height: 200px;<br>
@include normal-font(&quot;IBM Plex Sans&quot;);<br>
}</p>
<p>css:</p>
<p>.box {<br>
width: 200px;<br>
height: 200px;<br>
font-size: 18px;<br>
font-family: &quot;IBM Plex Sans&quot;;<br>
}</p>
</li>
<li>
<p>扩展与继承 sass中的扩展相当于不带参数的代码片段，适用于同一组件的不同状态，语法如下：</p>
<p>scss:</p>
<p>%message-shared {<br>
border: 1px solid #ccc;<br>
padding: 10px;<br>
color: #333;<br>
}</p>
<p>.message {<br>
@extend %message-shared;<br>
}</p>
<p>.success {<br>
@extend %message-shared;<br>
border-color: green;<br>
}</p>
<p>.error {<br>
@extend %message-shared;<br>
border-color: red;<br>
}</p>
<p>.warning {<br>
@extend %message-shared;<br>
border-color: yellow;<br>
}</p>
<p>css:</p>
<p>.warning, .error, .success, .message {<br>
border: 1px solid #ccc;<br>
padding: 10px;<br>
color: #333;<br>
}</p>
<p>.success {<br>
border-color: green;<br>
}</p>
<p>.error {<br>
border-color: red;<br>
}</p>
<p>.warning {<br>
border-color: yellow;<br>
}</p>
<p></p>
</li>
</ol>
<h3 id="模块化">模块化</h3>
<p>sass也借鉴了编程语言中的模块化思想，允许文件引入。以下划线开头的文件类似于子模块，不会被被sass编译为css，只能被其他scss文件引用。例如：</p>
<p>_module.scss:</p>
<p>.bass {<br>
padding: 0 20px;<br>
}</p>
<p>test.scss:</p>
<p>@import &quot;module&quot;;</p>
<p>$basic-margin: &quot;10px 20px&quot;;</p>
<p>#box01 {<br>
margin: $basic-margin;<br>
}</p>
<p>#box02 {<br>
margin: $basic-margin;<br>
}</p>
<p>test.css:</p>
<p>.bass {<br>
padding: 0 20px;<br>
}</p>
<p>#box01 {<br>
margin: &quot;10px 20px&quot;;<br>
}</p>
<p>#box02 {<br>
margin: &quot;10px 20px&quot;;<br>
}</p>
<h3 id="语法简化">语法简化</h3>
<p>scss也对css的语法做了一些简化，比如说：</p>
<ol>
<li>
<p>嵌套 写scss子元素的规则不再另起一条规则，只需要嵌套在父元素中的规则中即可，例如：</p>
<p>scss:</p>
<p>$basic-margin: &quot;10px 20px&quot;;</p>
<p>.bss {<br>
margin: $basic-margin;<br>
#dash {<br>
margin-top: 20px;<br>
padding-top: 20px;<br>
}<br>
.dash {<br>
margin-top: 20px;<br>
margin-bottom: 20px;<br>
}<br>
}</p>
<p>css:</p>
<p>.bss {<br>
margin: &quot;10px 20px&quot;;<br>
}<br>
.bss #dash {<br>
margin-top: 20px;<br>
padding-top: 20px;<br>
}<br>
.bss .dash {<br>
margin-top: 20px;<br>
margin-bottom: 20px;<br>
}</p>
<p>另一种方式的嵌套：</p>
<p>scss：</p>
<p>.box {<br>
margin: {<br>
top: 20px;<br>
bottom: 10px;<br>
right: 10px;<br>
left: 20px;<br>
}<br>
}</p>
<p>css:</p>
<p>.box {<br>
margin-top: 20px;<br>
margin-bottom: 10px;<br>
margin-right: 10px;<br>
margin-left: 20px;<br>
}</p>
</li>
</ol>
<h3 id="可编程化">可编程化</h3>
<p>sass也做了一些工作让css更像一门编程语言而不是一遍作文。其中包括：</p>
<ol>
<li>
<p>支持运算 css是不支持运算的，而在scss中可以做一些简单的运算，例如：</p>
<p>scss:</p>
<p>.box {<br>
width: 100px / 200px * 100%;<br>
}</p>
<p>css:</p>
<p>.box {<br>
width: 50%;<br>
}</p>
</li>
<li>
<p>数值类型 scss中的值分为以下几种类型：</p>
<ul>
<li>数字，例如： 20, 20px</li>
<li>字符串，例如：&quot;IBM Plex Sans&quot;, bold</li>
<li>颜色值，例如：#ffffff, blue</li>
<li>布尔值, true, false</li>
<li>列表，例如：0 20px 30px 40px</li>
<li>字典，例如：(&quot;background&quot;: red, &quot;foreground&quot;: pink)</li>
</ul>
</li>
<li>
<p>操作符 scss中的操作符包括：</p>
<ul>
<li>== , !=  : 判断两个值是否相等/不相等</li>
<li>+ - * / %</li>
<li>&lt; &lt;= &gt; &gt;=</li>
<li>and or not</li>
<li>+ - / 可用于字符串拼接</li>
<li>() 用于优先级设定</li>
<li>&amp;父元素选择器</li>
<li>#{} 可以将sass表达式插入到css的文本中</li>
</ul>
</li>
<li>
<p>代码注释</p>
<ul>
<li>// 单行注释，不会编译到css中</li>
<li>/**/多行注释，一般会被编译进css</li>
<li>压缩模式下，多行注释不会被编译进css，除非以/*!开头</li>
<li>///为文档注释，不会被编译到css中，会被sassdoc工具使用，生成sass的文档</li>
</ul>
</li>
<li>
<p>函数 scss中的函数主要用于数值计算，例如：</p>
<p>scss:</p>
<p>@function pow($base, $exponent) {<br>
$result: 1;<br>
@for $_ from 1 through $exponent {<br>
$result: $result * $base;<br>
}<br>
@return $result;<br>
}</p>
<p>.sidebar {<br>
float: left;<br>
margin-left: pow(4, 3) * 1px;<br>
}</p>
<p>css:</p>
<p>.sidebar {<br>
float: left;<br>
margin-left: 64px;<br>
}</p>
<p>Sass中的内建函数详见 <a href="https://sass-lang.com/documentation/functions">https://sass-lang.com/documentation/functions</a></p>
</li>
<li>
<p>流程控制</p>
<ul>
<li>
<p>分支 @if , @else, @else if 例如：</p>
<p>scss:</p>
<p>@mixin triangle($color, $size, $direction) {<br>
display: block;<br>
height: 0;<br>
width: 0;<br>
border: $size/2 solid transparent;</p>
<p>@if $direction == up {<br>
border-bottom-color: $color;<br>
} @else if $direction == down {<br>
border-top-color: $color;<br>
} @else if $direction == left {<br>
border-right-color: $color;<br>
} @else if $direction == right {<br>
border-left-color: <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;}&#039; at position 10: color;
  }̲ @else {
    @e…'>color;
  } @else {
    @error &quot;wrong direction: #{</span>direction}&quot;;<br>
}<br>
}</p>
<p>.next {<br>
@include triangle(green, 20px, right);<br>
}</p>
<p>css:</p>
<p>.next {<br>
display: block;<br>
height: 0;<br>
width: 0;<br>
border: 10px solid transparent;<br>
border-left-color: green;<br>
}</p>
</li>
<li>
<p>循环 @each @for @while 例如：</p>
<p>scss:</p>
<p>$sizes: 40px, 50px, 80px;</p>
<p>@each $size in <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;#&#039; at position 17: …izes {
  .icon-#̲{'>sizes {
  .icon-#{</span>size} {<br>
font-size: $size;<br>
height: $size;<br>
width: $size;<br>
}<br>
}</p>
<p>css:</p>
<p>.icon-40px {<br>
font-size: 40px;<br>
height: 40px;<br>
width: 40px;<br>
}</p>
<p>.icon-50px {<br>
font-size: 50px;<br>
height: 50px;<br>
width: 50px;<br>
}</p>
<p>.icon-80px {<br>
font-size: 80px;<br>
height: 80px;<br>
width: 80px;<br>
}</p>
<p>scss:<br>
$base-color: #036;</p>
<p>@for <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;}&#039;, got &#039;#&#039; at position 42: …nth-child(3n + #̲{'>i from 1 through 3 {
  ul:nth-child(3n + #{</span>i}) {<br>
background-color: lighten($base-color, $i * 5%);<br>
}<br>
}</p>
<p>css:</p>
<p>ul:nth-child(3n + 1) {<br>
background-color: #004080;<br>
}</p>
<p>ul:nth-child(3n + 2) {<br>
background-color: #004d99;<br>
}</p>
<p>ul:nth-child(3n + 3) {<br>
background-color: #0059b3;<br>
}</p>
<p>scss:<br>
@function scale-below($value, $base, $ratio: 1.618) {<br>
@while $value &gt; $base {<br>
$value: $value / $ratio;<br>
}<br>
@return $value;<br>
}</p>
<p>$normal-font-size: 16px;<br>
sup {<br>
font-size: scale-below(20px, 16px);<br>
}</p>
<p>css:<br>
sup {<br>
font-size: 12.36094px;<br>
}</p>
</li>
</ul>
</li>
<li>
<p>数值类型 sass中的数值类型包括以下几种：数值，字符串，颜色，List, Map，布尔值，null及函数</p>
<ul>
<li>
<p>数值包含数字和单位，sass的强大之处在于支持带单位的运算，例如：</p>
<p>@debug 1in + 6px; // 102px or 1.0625in</p>
</li>
<li>
<p>list和map的用法举例：</p>
<p>$prefixes-by-browser: (&quot;firefox&quot;: moz, &quot;safari&quot;: webkit, &quot;ie&quot;: ms);</p>
<p>@function prefixes-for-browsers($browsers) {<br>
$prefixes: ();<br>
@each $browser in $browsers {<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mi>i</mi><mi>x</mi><mi>e</mi><mi>s</mi><mo>:</mo><mi>a</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mo>(</mo></mrow><annotation encoding="application/x-tex">prefixes: append(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mopen">(</span></span></span></span>prefixes, map-get($prefixes-by-browser, $browser));<br>
}<br>
@return $prefixes;<br>
}</p>
<p>@debug prefixes-for-browsers(&quot;firefox&quot; &quot;ie&quot;); // moz ms</p>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[获取隐藏元素的宽度]]></title>
        <id>https://sanmuny.github.io/post/e8-8e-b7-e5-8f-96-e9-9a-90-e8-97-8f-e5-85-83-e7-b4-a0-e7-9a-84-e5-ae-bd-e5-ba-a6/</id>
        <link href="https://sanmuny.github.io/post/e8-8e-b7-e5-8f-96-e9-9a-90-e8-97-8f-e5-85-83-e7-b4-a0-e7-9a-84-e5-ae-bd-e5-ba-a6/">
        </link>
        <updated>2019-01-11T08:10:54.000Z</updated>
        <content type="html"><![CDATA[<h4 id="问题描述">问题描述</h4>
<p>如果DOM元素的fu'yu是被隐藏的(display: none)，那么无论使用DOM的接口，还是jquery的接口来获取该元素的宽度，得到的结果始终是0. 例如：</p>
<pre><code>&lt;div id=&quot;node&quot;&gt;
&lt;p&gt;
    hello world
&lt;/p&gt;
&lt;/div&gt;

#node {
    display: none;
}

alert($('#node p').width());
</code></pre>
<h4 id="解决方法">解决方法</h4>
<p>在过去元素的宽度之前，临时修改元素的display为block，获取之后再讲其设置回none 例如：</p>
<pre><code>function get_width(obj) {
var width = 0;
  obj.parent().css('display', 'block');
width = obj.width();
obj.parent().css('display', 'none');
return width;
}
alert(get_width($('#node p')));
</code></pre>
<h4 id="给jquery添加一个函数">给jquery添加一个函数</h4>
<p>参考<a href="https://stackoverflow.com/questions/1472303/jquery-get-width-of-element-when-not-visible-display-none">StackOverflow</a> ,Tim Banks给jquery添加了一个函数，用来获取隐藏元素的宽度和高度信息。</p>
<pre><code>(function ($) {
$.fn.getHiddenDimensions = function (include_margin) {
    var $item = this,
    props = { position: 'absolute', visibility: 'hidden', display: 'block' },
    dim = { width: 0, height: 0, innerWidth: 0, innerHeight: 0, outerWidth: 0, outerHeight: 0 },
    $hiddenParents = $item.parents().addBack().not(':visible'),
    includeMargin = (include\_margin == null) ? false : include\_margin;

    var oldProps = \[\];
    $hiddenParents.each(function () {
        var old = {};

        for (var name in props) {
            old\[name\] = this.style\[name\];
            this.style\[name\] = props\[name\];
        }

        oldProps.push(old);
    });

    dim.width = $item.width();
    dim.outerWidth = $item.outerWidth(includeMargin);
    dim.innerWidth = $item.innerWidth();
    dim.height = $item.height();
    dim.innerHeight = $item.innerHeight();
    dim.outerHeight = $item.outerHeight(includeMargin);

    $hiddenParents.each(function (i) {
        var old = oldProps\[i\];
        for (var name in props) {
            this.style\[name\] = old\[name\];
        }
    });

    return dim;
}
}($));
alert($('#node p').getHiddenDimensions().width);
</code></pre>
<p>在jsFiddle上试一试 <a href="https://jsfiddle.net/sen_wang/za7L1e8g/">-&gt;</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6: 模块编程]]></title>
        <id>https://sanmuny.github.io/post/es6-e6-a8-a1-e5-9d-97-e7-bc-96-e7-a8-8b/</id>
        <link href="https://sanmuny.github.io/post/es6-e6-a8-a1-e5-9d-97-e7-bc-96-e7-a8-8b/">
        </link>
        <updated>2019-01-08T13:34:59.000Z</updated>
        <content type="html"><![CDATA[<h4 id="javascript模块的限制">Javascript模块的限制</h4>
<ul>
<li>只能运行于严格模式</li>
<li>模块中的顶级作用域中的变量，不会被自动添加到全局作用域</li>
<li>顶级作用域的this为undefined</li>
</ul>
<h4 id="导出">导出</h4>
<p>如果想让模块中的变量、函数、类被其他模块使用，需要将其导出，导出的方法如下：</p>
<ul>
<li>export var color = &quot;red&quot;;</li>
<li>export function print_hello(){};</li>
<li>export { print_hello }</li>
<li>export { print_hello as printh };</li>
<li>export default function print_hello(){};</li>
<li>export default print_hello</li>
<li>export { print_hello as default}</li>
</ul>
<h4 id="导入">导入</h4>
<p>如果想使用其他模块中的变量、函数、类，需要将其导入。导入后的变量、类、函数为只读。导入的方法如下：</p>
<ul>
<li>import { color, print_hello } from &quot;./example.js&quot;;</li>
<li>import * as example from &quot;./example.js&quot;;  //example.color, example.print_hello</li>
<li>import { print_hello as printh } from &quot;./example.js&quot;;</li>
<li>import print_hello, { color } from &quot;./example.js&quot;; // print_hello 为默认导出的函数</li>
<li>import { default as printh } from &quot;./example.js&quot;;</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6：数组]]></title>
        <id>https://sanmuny.github.io/post/es6-ef-bc-9a-e6-95-b0-e7-bb-84/</id>
        <link href="https://sanmuny.github.io/post/es6-ef-bc-9a-e6-95-b0-e7-bb-84/">
        </link>
        <updated>2019-01-03T08:25:11.000Z</updated>
        <content type="html"><![CDATA[<h4 id="新增的静态方法">新增的静态方法</h4>
<p>Array.of() ：可以将传入的参数逐个传入数组，即使只有一个数值类型的参数，也会成为新数组的成员，而不是代表数组的长度 Array.from()：可以将类数组结构转化为数组，例如: Array.from(arguments). 利用Array.from()也可以转换原来的数组，例如：</p>
<pre><code>let trans_args = function() {
    let args = Array.from(arguments, (value)=&gt;value + 1);
    console.log(args);
}

trans_args(1, 2, 3);

$ node test.js 
[ 2, 3, 4 ]
</code></pre>
<h4 id="新增的普通方法">新增的普通方法</h4>
<p>find() 与findIndex()：传入一个回调函数来表明查找的条件，例如：</p>
<pre><code>&gt; let arr = [1, 2, 3, 4, 5];
undefined
&gt; arr.find((n)=&gt;n&gt;3);
4
&gt; arr.findIndex((n)=&gt;n&gt;3);
3
</code></pre>
<p>fill(value, start, end)：填充value到数组的start到end位置，不包括end. 例如：</p>
<pre><code>let arr = [1, 2, 3, 4, 5];
arr.fill(1, 1, 4);
[ 1, 1, 1, 1, 5 ]
</code></pre>
<p>copyWithin(toIndex, fromIndex, stopIndex): 从fromIndex开始复制元素到toIndex，遇到stopIndex停止，例如：</p>
<pre><code>&gt; let arr = [1, 2, 3, 4, 5]
undefined
&gt; arr.copyWithin(2, 0, 1);
[ 1, 2, 1, 4, 5 ]
</code></pre>
<h4 id="类型化数组">类型化数组</h4>
<p>javascript中的数组缓冲区类似于c的malloc，例如，可以用如下方法分配一个10个字节大小的内存区域：</p>
<pre><code>&gt; let bu = new ArrayBuffer(10);
undefined
&gt; bu.byteLength
10
</code></pre>
<p>可以使用slice(start, end)方法来对分配的内存进行切片。 要操作新分配的内存，需要使用DataView(buf, index, length)创建一个视图，例如：</p>
<pre><code>&gt; let buf = new ArrayBuffer(50);
&gt; let view = new DataView(buf, 0, 50);
</code></pre>
<p>获取视图的信息：</p>
<pre><code>&gt; view.buffer === buf;
true
&gt; view.byteOffset
0
&gt; view.byteLength
50
</code></pre>
<p>读写数据：</p>
<pre><code>&gt; view.setUint8(4, 233);
undefined
&gt; view.getUint8(4)
233</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6中的类]]></title>
        <id>https://sanmuny.github.io/post/es6-e4-b8-ad-e7-9a-84-e7-b1-bb/</id>
        <link href="https://sanmuny.github.io/post/es6-e4-b8-ad-e7-9a-84-e7-b1-bb/">
        </link>
        <updated>2019-01-02T09:43:54.000Z</updated>
        <content type="html"><![CDATA[<p>ES6中添加的class关键字其实并非真正的类，而是ES5用函数来模拟类的语法糖。在ES6中可以用如下的语法创建一个类：</p>
<pre><code>class Students {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    sayName() {
        console.log(this.name);
    }
    sayAge() {
        console.log(this.age);
    }
}

let st1 = new Students('sen', 18);
st1.sayName();
st1.sayAge();
</code></pre>
<p>使用ES6的class语法糖和ES5自定义的类还是有些区别的：</p>
<ul>
<li>类的声明不会被提升，类的实例化只能在类的声明之后</li>
<li>类声明中的代码只能运行在严格模式下</li>
<li>类中的方法是不可枚举的</li>
<li>实例化的时候必须加new关键字</li>
<li>在方法内部修改类名会抛出错误，但可以在外部修改类名</li>
</ul>
<p>下面的例子展示了如何在外部修改类名：</p>
<pre><code>class Students {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    sayName() {
        console.log(this.name);
    }
    sayAge() {
        console.log(this.age);
    }
}

let st1 = new Students('sen', 18);
st1.sayName();
st1.sayAge();

let Stu = Students;

let st2 = new Stu('sen', 18);
st2.sayName();
st2.sayAge();

console.log(st1 instanceof Students); //true
console.log(st2 instanceof Students); //true
console.log(st2 instanceof Stu); //true
console.log(st1 instanceof Stu); //true
</code></pre>
<h4 id="类中的访问器属性">类中的访问器属性</h4>
<p>可以使用get和set关键字来定义访问器属性，例如：</p>
<pre><code>class Students {
    constructor(name) {
        this.name = name;
    }
    get n() {
        return this.name;
    }
    set n(value) {
        this.name = value;
    }
}

let st1 = new Students('sen', 18);
console.log(st1.n);
st1.n = 'wang';
console.log(st1.n);
</code></pre>
<h4 id="需计算的属性名">需计算的属性名</h4>
<p>和其他需计算的名字一样，都是加上方括号，例如：</p>
<p>let propName = &quot;sayName&quot;;</p>
<pre><code>class Students {
    constructor(name) {
        this.name = name;
    }
    [propName]() {
        console.log(this.name);
    }
}

let st1 = new Students('sen');
st1.sayName();
</code></pre>
<h4 id="给类添加默认的生成器">给类添加默认的生成器</h4>
<p>可以利用Symbol来给类添加默认的生成器，如：</p>
<pre><code>class Collection {
    constructor() {
        this.items = [];
    }
    *[Symbol.iterator]() {
        yield *this.items.values();
    }
}

let col = new Collection();
col.items.push(1);
col.items.push(2);
col.items.push(3);
for( let i of col) {
    console.log(i);
}
</code></pre>
<h4 id="给类添加静态属性方法">给类添加静态属性/方法</h4>
<p>类的静态方法/属性只能通过类名来访问，而不能通过类的实例来访问，具体做法是在方法/属性定义前面加上static关键字，例如：</p>
<pre><code>class Students {
    constructor(name) {
        this.name = name;
    }
    static sayClassName() {
        console.log(&quot;Collection&quot;);
    }
}

Students.sayClassName();
let stu = new Students('sen');
stu.sayClassName(); // error
</code></pre>
<h4 id="类的继承">类的继承</h4>
<p>ES6引入了extends和super来实现类的继承，例如：</p>
<pre><code>class Rectangle {
    constructor(length, width) {
        this.length = length;
        this.width = width;
    }
    getArea() {
        return this.length * this.width;
    }
}

class Square extends Rectangle {
    constructor(length) {
        super(length, length);
    }
}

let sq = new Square(5);
console.log(sq.getArea());
</code></pre>
<p>使用super需要注意：</p>
<ul>
<li>super只能用在派生类中</li>
<li>在constructor里，super负责初始化this，所以必须在this使用之前调用</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ES6: 迭代器与生成器]]></title>
        <id>https://sanmuny.github.io/post/es6-e8-bf-ad-e4-bb-a3-e5-99-a8-e4-b8-8e-e7-94-9f-e6-88-90-e5-99-a8/</id>
        <link href="https://sanmuny.github.io/post/es6-e8-bf-ad-e4-bb-a3-e5-99-a8-e4-b8-8e-e7-94-9f-e6-88-90-e5-99-a8/">
        </link>
        <updated>2018-12-07T08:23:24.000Z</updated>
        <content type="html"><![CDATA[<h4 id="什么是迭代器">什么是迭代器？</h4>
<p>迭代器是一个对象，它拥有一个next方法，调用next方法会返回一个对象，该对象有两个属性值，value和done。每次调用next方法，返回的value表示可迭代对象中的下一个值，done表示迭代是否完成。根据此定义，可用下面的代码实现一个迭代器:</p>
<pre><code>let create_iter = function(items) {
    let i = 0;
    return {
        next: function() {
            let value, done;
            if (i &gt;= items.length) {
                value = null;
                done = true;
            } else {
                value = items\[i++\];
                done = false;
            }
            return {
                value: value,
                done: done
            }
        }
    }
}
</code></pre>
<h4 id="什么是生成器">什么是生成器？</h4>
<p>用来创建迭代器的函数称之为生成器，ES6为了简化生成器，引入了新的语法：</p>
<ul>
<li>在生成器函数前加*</li>
<li>使用yield关键字抛出下一个value</li>
</ul>
<p>引入新的语法后，生成器的代码可以简化为：</p>
<pre><code>let gen = function*(items) {
    for (let i = 0; i &lt; items.length; i++) {
        yield items\[i\];
    }
}
</code></pre>
<h4 id="举个栗子">举个栗子</h4>
<p>下面的代码比较了两种创建迭代器的方法：</p>
<pre><code>let create_iter = function(items) {
    let i = 0;
    return {
        next: function() {
            let value, done;
            if (i &gt;= items.length) {
                value = null;
                done = true;
            } else {
                value = items[i++];
                done = false;
            }
            return {
                value: value,
                done: done
            }
        }
    }
}

let gen = function*(items) {
    for (let i = 0; i &lt; items.length; i++) {
        yield items[i];
    }
}

let items = [1, 2, 3, 4, 5];

let it = gen(items);
console.log(it.next());
console.log(it.next());
console.log(it.next());
console.log(it.next());
console.log(it.next());
console.log(it.next());
</code></pre>
<p>输出结果：</p>
<pre><code>$ node test.js 
{ value: 1, done: false }
{ value: 2, done: false }
{ value: 3, done: false }
{ value: 4, done: false }
{ value: 5, done: false }
{ value: undefined, done: true }
{ value: undefined, done: true }
</code></pre>
<h4 id="生成器的表现形式">生成器的表现形式</h4>
<ul>
<li>function *my_generator(items) {}</li>
<li>let my_generator = function *(items) {}</li>
<li>let obj = {*my_generator(items){}};</li>
</ul>
<h4 id="可迭代对象">可迭代对象</h4>
<p>可迭代对象指的是包含Symbol.iterator属性的对象，数组、Set、Map、字符串都是可迭代对象，都有默认的迭代器。 可迭代对象可以与for-of配合使用，例如：</p>
<pre><code>let numbers = [1, 2, 3, 4, 5];
for (let num of numbers) {
    console.log(num);
}
</code></pre>
<p>可以用一下方法自定义一个可迭代对象：</p>
<pre><code>let colors = {
    items: [1, 2, 3, 4, 5],
    *[Symbol.iterator]() {
        for (let item of this.items) {
            yield item;
        }
    }
}
</code></pre>
<h4 id="内置迭代器">内置迭代器</h4>
<p>数组、Map和Set 都有一下三个内置的迭代器：</p>
<ul>
<li>entries(): 返回一个包含键值对(数组)的迭代器</li>
<li>values(): 返回一个只包含值的迭代器</li>
<li>keys(): 返回一个只包含键的迭代器</li>
</ul>
<p>对于数组来说，keys返回的是元素的下标，对于Set来说，返回的是元素的值，而对于Map来说，返回的是元素的key。</p>
<h4 id="给迭代器传入参数">给迭代器传入参数</h4>
<p>当调用next方法时，若传入参数，则该参数会替代上一次yield表达式的值，例如：</p>
<pre><code>let gen = function *() {
    let a = yield 1;
    let b = yield a + 1;
    yield b + 1;
}

let iter = gen();

console.log(iter.next());
console.log(iter.next(100));
console.log(iter.next(200));
console.log(iter.next());

执行结果：

$ node test.js 
{ value: 1, done: false }
{ value: 101, done: false }
{ value: 201, done: false }
{ value: undefined, done: true }

#### 生成器委托

也就是生成器的嵌套，例如：

let generator0 = function *() {
    yield 0;
    yield 1;
    yield 2;
}

let generator1 = function *() {
    yield 3;
    yield 4;
    yield 5;
}

let generator = function *() {
    yield *generator0();
    yield *generator1();
    yield 6;
}

let iter = generator();

console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单链表反转]]></title>
        <id>https://sanmuny.github.io/post/e5-8d-95-e9-93-be-e8-a1-a8-e5-8f-8d-e8-bd-ac/</id>
        <link href="https://sanmuny.github.io/post/e5-8d-95-e9-93-be-e8-a1-a8-e5-8f-8d-e8-bd-ac/">
        </link>
        <updated>2018-12-07T06:43:11.000Z</updated>
        <content type="html"><![CDATA[<h4 id="实现单链表反转的思路">实现单链表反转的思路</h4>
<p>实现单链表反转的难点在于，如果让当前节点的next指向前驱节点，那么链表就断了，所以解决的办法就是在进行反转操作之前用一个临时指针变量保存后继节点的地址。</p>
<h4 id="单链表反转的代码实现">单链表反转的代码实现</h4>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct LIST_NODE {
    int data;
    struct LIST_NODE* next;
} LIST_NODE;

void show\_list(LIST\_NODE *head) {
    LIST_NODE *p = head-&gt;next;

    while(p != NULL) {
        printf(&quot;%d &quot;, p-&gt;data);
        p = p-&gt;next;
    }
    printf(&quot;\\n&quot;);
}

void reverse\_list(LIST\_NODE *head) {
    LIST_NODE \*p, \*q, *tmp;
    p = head;
    q = p-&gt;next;

    while (q != NULL) {
        tmp = q-&gt;next;
        if (p == head) {
            q-&gt;next = NULL;
        } else {
            q-&gt;next = p;
        }
        p = q;
        q = tmp;
    }
    head-&gt;next = p;
}

int main(int argc, char **argv) {
    LIST_NODE head = {
        .data = 0,
        .next = NULL
    };
    int data;
    LIST_NODE *tail = &amp;head;
    while (1) {
        printf(&quot;Please input a number: (0 to stop input)\\n&quot;);
        scanf(&quot;%d&quot;, &amp;data);
        if (data == 0) {
            break;
        }
        LIST\_NODE *new\_node = malloc(sizeof(LIST_NODE));
        new_node-&gt;data = data;
        new_node-&gt;next = NULL;
        tail-&gt;next = new_node;
        tail = new_node;
    }
    show_list(&amp;head);
    reverse_list(&amp;head);
    show_list(&amp;head);
    return 0;
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[冒泡排序、插入法排序及选择排序]]></title>
        <id>https://sanmuny.github.io/post/e5-86-92-e6-b3-a1-e6-8e-92-e5-ba-8f-e3-80-81-e6-8f-92-e5-85-a5-e6-b3-95-e6-8e-92-e5-ba-8f-e5-8f-8a-e9-80-89-e6-8b-a9-e6-8e-92-e5-ba-8f/</id>
        <link href="https://sanmuny.github.io/post/e5-86-92-e6-b3-a1-e6-8e-92-e5-ba-8f-e3-80-81-e6-8f-92-e5-85-a5-e6-b3-95-e6-8e-92-e5-ba-8f-e5-8f-8a-e9-80-89-e6-8b-a9-e6-8e-92-e5-ba-8f/">
        </link>
        <updated>2018-11-22T07:51:02.000Z</updated>
        <content type="html"><![CDATA[<p>冒泡排序、插入法排序以及选择排序是排序算法中比较基础的三种，其平均时间复杂度都是O(n^2)。 <img src="https://static001.geekbang.org/resource/image/34/50/348604caaf0a1b1d7fee0512822f0e50.jpg" alt="" loading="lazy"></p>
<h3 id="原理介绍">原理介绍</h3>
<h4 id="冒泡排序">冒泡排序</h4>
<p>冒泡排序的步骤是：比较相邻两个数，看是否满足大小关系，如果不满足则交换这两个数，使他们满足大小关系，这样可以保证最大（最小）的数始终会向后流动，循环一次之后，最大（最小）的数就会被交换到数组的最后。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p>
<h4 id="插入法排序">插入法排序</h4>
<p>插入法排序的思路是：把数组分成两个部分：排好序的，和未排序的。开始的时候，数组的第一个元素会被当做拍好序的部分，对其余未排好序的数值进行迭代，将其插入到排好序的部分中合适的位置。</p>
<h4 id="选择法排序">选择法排序</h4>
<p>选择法排序和插入法排序类似，都是将数组分为排好序的和未排序的两个部分。不同的是，选择法排序每次迭代都会选择未排序部分中的最小（最大）值，将其插入到排好序部分的队首（队尾）。</p>
<h3 id="c语言实现">C语言实现</h3>
<p>需要实现四个函数， 第一个是打印数组，接下来三个函数分别实现三种排序算法：</p>
<ul>
<li>void print_arry(int *a, int len)</li>
<li>static inline void insertion_sort(int *a, int len)</li>
<li>static inline void bubble_sort(int *a, int len)</li>
<li>static inline void selection_sort(int *a, int len)</li>
</ul>
<p>main函数中，首先需要用户输入指定数目(#define LEN 10)的数值，如果用户输入-1则随机生成这些数值。然后需要用户输入排序算法。输入完成后打印排序前的数组，然后根据相应的排序算法进行排序，最后再打印出排序后的数组。代码如下：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;

#define LEN 10
#define NR_METHOD 3
#define RAND_RANGE 100

void print_arry(int *a, int len) {
    int i = 0;
    for (int i = 0; i &lt; len; i++) {
        printf(&quot;%d &quot;, a\[i\]);
    }
    printf(&quot;\\n&quot;);
}

static inline void insertion_sort(int *a, int len) {
    int tmp = 0;
    int i, j;
    for (i = 1; i &lt; len; i++) {
        tmp = a\[i\];
        for (j = i - 1; j &gt;= 0; j--) {
            if (a\[j\] &gt; tmp) {
                a\[j + 1\] = a\[j\];
            } else {
                break;
            }
        }
        a\[j + 1\] = tmp;
    }
}

static inline void bubble_sort(int *a, int len) {
    int i, j;
    int tmp;
    int swapped = 0;
    for (i = len - 1; i &gt;= 0; i--) {
        for (j = 0; j &lt; i; j++) {
            if (a\[j\] &gt; a\[j + 1\]) {
                tmp = a\[j\];
                a\[j\] = a\[j + 1\];
                a\[j + 1\] = tmp;
                swapped = 1;
            }
        }
        if (!swapped) {
            break;
        }
    }
}

static inline void selection_sort(int *a, int len) {
    int i, j, min, tmp;
    for (i = 0; i &lt; len -1; i++) {
        min = i;
        for (j = i + 1; j &lt; len; j++) {
            if(a\[j\] &lt; a\[min\]) {
                min = j;
            }
        }
        if (min != i) {
            tmp = a\[min\];
            a\[min\] = a\[i\];
            a\[i\] = tmp;
        }
    }
}

int main(int argc, char **argv) {
    srand(time(NULL));

    int a\[LEN\];
    int data;

    for (int i = 0; i &lt; LEN; i++) {
        printf(&quot;Please input a number: %d left: (-1 for random numbers)&quot;, LEN - i);
        scanf(&quot;%d&quot;, &amp;data);
        if(data != -1) {
            a\[i\] = data;
        } else {
            for (int j = 0; j &lt; LEN; j++) {
                a\[j\] = rand() % RAND_RANGE;
            }
            break;
        }
    }

    while (1) {
        printf(&quot;Please select a sort method:\\n&quot;);
        printf(&quot;0: Insertion sort\\n&quot;);
        printf(&quot;1: Bubble sort \\n&quot;);
        printf(&quot;2: Selection sort \\n&quot;);
        scanf(&quot;%d&quot;, &amp;data);
        if(data &gt;= 0 &amp;&amp; data &lt; NR_METHOD) {
            break;
        } else {
            printf(&quot;Please input a valid number!\\n&quot;);
        }
    }

    printf(&quot;Original Array: \\n&quot;);
    print_arry(a, LEN);

    switch(data) {
        case 0:
        printf(&quot;You selected insertion sort\\n&quot;);
        insertion_sort(a, LEN);
        break;
        case 1:
        printf(&quot;You selected bubble sort\\n&quot;);
        bubble_sort(a, LEN);
        break;
        case 2:
        printf(&quot;You selected selection sort\\n&quot;);
        selection_sort(a, LEN);
        break;
    }

    printf(&quot;Sorted Array: \\n&quot;);
    print_arry(a, LEN);

    return 0;
}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用单链表实现LRU缓存置换算法]]></title>
        <id>https://sanmuny.github.io/post/e7-94-a8-e5-8d-95-e9-93-be-e8-a1-a8-e5-ae-9e-e7-8e-b0lru-e7-bc-93-e5-ad-98-e7-bd-ae-e6-8d-a2-e7-ae-97-e6-b3-95/</id>
        <link href="https://sanmuny.github.io/post/e7-94-a8-e5-8d-95-e9-93-be-e8-a1-a8-e5-ae-9e-e7-8e-b0lru-e7-bc-93-e5-ad-98-e7-bd-ae-e6-8d-a2-e7-ae-97-e6-b3-95/">
        </link>
        <updated>2018-10-30T15:47:22.000Z</updated>
        <content type="html"><![CDATA[<h4 id="缓存置换算法所解决的问题">缓存置换算法所解决的问题</h4>
<p>在存储系统的金字塔结构中，缓存的存取速度比内存快，然而成本比内存高，所以缓存的容量有限。缓存置换算法所要解决的问题便是在容量有限的缓存中，存放哪些数据可以提升缓存命中率。</p>
<h4 id="lru缓存置换算法的核心思想">LRU缓存置换算法的核心思想</h4>
<p>LRU算法认为最近访问过的数据被再次访问的可能性最大，所以缓存中存放的是最近使用过的数据。具体的做法是：</p>
<ul>
<li>把缓存当做一个队列，队首的数据是最近被访问的数据，而队尾的数据则是即将被置换出缓存的数据。</li>
<li>每当有新数据被访问时，会在队列中查找该数据，如果存在，就被该数据挪到队首。</li>
<li>如果被访问的数据没有在队列（缓存）中，而且缓存未满，则该数据被放到队首。</li>
<li>如果被访问的数据没有在队列中，然而缓存已经满了，则把队尾的数据从队列中删除，再把新数据放置到队首。</li>
</ul>
<p></p>
<h4 id="用c语言实现lru缓存置换算法">用C语言实现LRU缓存置换算法</h4>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define CACHE_SIZE 20

int nr_of_list = 0;

typedef struct CACHE_ITEM {
    int data;
    struct CACHE_ITEM *next;
} CACHE_ITEM;

CACHE_ITEM list_head;

int init_list_head(CACHE_ITEM *head) {
    if (!head) {
        printf(&quot;%s: parameter error - no list head\n&quot;, __func__);
        return -1;
    }
    head-&gt;data = 0;
    head-&gt;next = NULL;
    return 0;
}

int insert_node(CACHE_ITEM *head, CACHE_ITEM *node) {
    if (!head || !node) {
        printf(&quot;%s: parameter error - no list head or node\n&quot;, __func__);
        return -1;
    }
    node-&gt;next = head-&gt;next;
    head-&gt;next = node;
    nr_of_list += 1;
    return 0;
}

int remove_node(CACHE_ITEM *head, CACHE_ITEM *node) {
    if (!head || !node) {
        printf(&quot;%s: parameter error - no list head or node\n&quot;, __func__);
        return -1;
    }
    CACHE_ITEM *p = head;
    while(p-&gt;next) {
        if(p-&gt;next == node) {
            p-&gt;next = node-&gt;next;
            nr_of_list -= 1;
        } else {
            p = p-&gt;next;
        }
    }
    return 0;
}

int remove_tail_node(CACHE_ITEM *head) {
    if (!head) {
        printf(&quot;%s: parameter error - no list head\n&quot;, __func__);
        return -1;
    }
    CACHE_ITEM *p = head;
    while(p-&gt;next) {
        if(p-&gt;next &amp;&amp; !p-&gt;next-&gt;next) {
            p-&gt;next = NULL;
            nr_of_list -= 1;
        } else {
            p = p-&gt;next;
        }
    }
    return 0;
}

CACHE_ITEM *search_list(CACHE_ITEM *head, int number) {
    if (!head) {
        printf(&quot;%s: parameter error - no list head\n&quot;, __func__);
        return NULL;
    }
    CACHE_ITEM *p = head-&gt;next;
    CACHE_ITEM *q = NULL;
    while(p) {
        if(p-&gt;data == number) {
            q = p;
            break;
        } else {
            p = p-&gt;next;
        }
    }
    return q;
}

void show_list(CACHE_ITEM *head) {
    CACHE_ITEM *p = head-&gt;next;
    while(p) {
        printf(&quot;%d &quot;, p-&gt;data);
        p = p-&gt;next;
    }
    printf(&quot;\n&quot;);
    printf(&quot;List Length: %d\n&quot;, nr_of_list);
}

int lru(CACHE_ITEM *head, int number) {
    if (!head) {
        printf(&quot;%s: parameter error - no list head\n&quot;, __func__);
        return -1;
    }
    CACHE_ITEM *p = search_list(head, number);
    if (p) {
        remove_node(head, p);
        insert_node(head, p);
    } else if (nr_of_list &lt; CACHE_SIZE) {
        CACHE_ITEM *new_node = (CACHE_ITEM *)malloc(sizeof(CACHE_ITEM));
        new_node-&gt;data = number;
        insert_node(head, new_node);
    } else {
        remove_tail_node(head);
        CACHE_ITEM *new_node = (CACHE_ITEM *)malloc(sizeof(CACHE_ITEM));
        new_node-&gt;data = number;
        insert_node(head, new_node);
    }
    return 0;
}

int main(int argc, char **argv) {
    CACHE_ITEM *head = &amp;list_head;
    init_list_head(head);
    int num = 0;
    while(1) {
        printf(&quot;请输入数字：\n&quot;);
        scanf(&quot;%d&quot;, &amp;num);
        lru(head, num);
        show_list(head);
    }
    return 0;
}

#### 运行结果

请输入数字：

1

1

List Length: 1

请输入数字：

2

2 1

List Length: 2

请输入数字：

3

3 2 1

List Length: 3

请输入数字：

4

4 3 2 1

List Length: 4

请输入数字：

5

5 4 3 2 1

List Length: 5

请输入数字：

3

3 5 4 2 1

List Length: 5

请输入数字：

1

1 3 5 4 2

List Length: 5

请输入数字：

6

6 1 3 5 4 2

List Length: 6

请输入数字：

7

7 6 1 3 5 4 2

List Length: 7

请输入数字：

8

8 7 6 1 3 5 4 2

List Length: 8

请输入数字：

9

9 8 7 6 1 3 5 4 2

List Length: 9

请输入数字：

10

10 9 8 7 6 1 3 5 4 2

List Length: 10

请输入数字：

11

11 10 9 8 7 6 1 3 5 4 2

List Length: 11

请输入数字：

12

12 11 10 9 8 7 6 1 3 5 4 2

List Length: 12

请输入数字：

13

13 12 11 10 9 8 7 6 1 3 5 4 2

List Length: 13

请输入数字：

14

14 13 12 11 10 9 8 7 6 1 3 5 4 2

List Length: 14

请输入数字：

15

15 14 13 12 11 10 9 8 7 6 1 3 5 4 2

List Length: 15

请输入数字：

16

16 15 14 13 12 11 10 9 8 7 6 1 3 5 4 2

List Length: 16

请输入数字：

17

17 16 15 14 13 12 11 10 9 8 7 6 1 3 5 4 2

List Length: 17

请输入数字：

18

18 17 16 15 14 13 12 11 10 9 8 7 6 1 3 5 4 2

List Length: 18

请输入数字：

19

19 18 17 16 15 14 13 12 11 10 9 8 7 6 1 3 5 4 2

List Length: 19

请输入数字：

20

20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 1 3 5 4 2

List Length: 20

请输入数字：

21

21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 1 3 5 4

List Length: 20

请输入数字：

22

22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 1 3 5

List Length: 20

请输入数字：

23

23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 1 3

List Length: 20

请输入数字：

1

1 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 3

List Length: 20

请输入数字：

4

4 1 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6

List Length: 20</code></pre>
]]></content>
    </entry>
</feed>